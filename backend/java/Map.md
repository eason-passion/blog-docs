## Map

### HashMap底层数据结构

DK1.7的数据结构是`数组`+`链表`，JDK1.8的数据结构是`数组`+`链表`+`红黑树`。

桶数组是用来存储数据元素，链表是用来解决冲突，红黑树是为了提高查询的效率。

* 数据元素通过映射关系，也就是散列函数，映射到桶数组对应索引的位置

* 如果发生冲突，从冲突的位置拉一个链表，插入冲突的元素

* 如果链表长度>8&数组大小>=64，链表转为红黑树

* 如果红黑树节点个数<6 ，转为链表

### 红黑树

红黑树本质上是一种二叉查找树，为了保持平衡，它又在二叉查找树的基础上增加了一些规则：

1. 每个节点要么是红色，要么是黑色；

2. 根节点永远是黑色的；

3. 所有的叶子节点都是是黑色的（注意这里说叶子节点其实是图中的 NULL 节点）；

4. 每个红色节点的两个子节点一定都是黑色；

5. 从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点；

### 红黑树如何保证平衡？

黑树有两种方式保持平衡：`旋转`和`染色`

### HashMap为什么要用红黑树，为什么不用二叉树、平衡树？

红黑树是一种平衡的二叉树，插入、删除、查找的最坏时间复杂度都为 O(logn)，避免了二叉树最坏情况下的O(n)时间复杂度。

平衡二叉树是比红黑树更严格的平衡树，为了保持保持平衡，需要旋转的次数更多，也就是说平衡二叉树保持平衡的效率更低，所以平衡二叉树插入和删除的效率比红黑树要低。

### HashMap 的 put 流程

哈希寻址 → 处理哈希冲突（链表还是红⿊树）→ 判断是否需要扩容 → 插⼊/覆盖节点。

1. 首先进行哈希值的扰动，获取一个新的哈希值。`(key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);`

2. 判断tab是否位空或者长度为0，如果是则进行扩容操作。

3. 根据哈希值计算下标，如果对应小标正好没有存放数据，则直接插入即可否则需要覆盖。`tab[i = (n - 1) & hash])`

4. 判断tab\[i]是否为树节点，否则向链表中插入数据，是则向树中插入节点。

5. 如果链表中插入节点的时候，链表长度大于等于8，则需要把链表转换为红黑树。`treeifyBin(tab, hash);`

6. 最后所有元素处理完成后，判断是否超过阈值；`threshold`，超过则扩容。

### 只重写元素的 equals ⽅法没重写 hashCode，put 的时候会发生什么?

如果只重写 equals ⽅法，没有重写 hashCode ⽅法，那么会导致 equals 相等的两个对象，hashCode 不相等， 这样的话，两个对象会被 put 到数组中不同的位置，导致 get 的时候，⽆法获取到正确的值。

### HashMap怎么get查找元素？

1. 使用扰动函数，获取新的哈希值

2. 计算数组下标，获取节点

3. 当前节点和key匹配，直接返回

4. 否则，当前节点是否为树节点，查找红黑树

5. 否则，遍历链表查找

### HashMap的hash函数？

HashMap的哈希函数是先拿到 key 的hashcode，是一个32位的int类型的数值，然后让hashcode的高16位和低16位进行异或操作。

```java
 static final int hash(Object key) {
        int h;
        // key的hashCode和key的hashCode右移16位做异或运算
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
```

为了降低哈希碰撞的概率。



### 为什么HashMap的容量是2的幂次方？

为了快速定位元素在底层数组中的下标。&#x20;

HashMap 是通过 hash & (n-1) 来定位元素下标的，n 为数组的⼤⼩，也就是 HashMap 底层数组的容量。 数组⻓度-1 正好相当于⼀个“低位掩码”——掩码的低位最好全是 1，这样 & 运算才有意义，否则结果⼀定是 0。

&#x20;2 幂次⽅刚好是偶数，偶数-1 是奇数，奇数的⼆进制最后⼀位是 1，也就保证了 hash &(length-1) 的最后⼀位 可能为 0，也可能为 1（取决于 hash 的值），这样可以保证哈希值的均匀分布。

换句话说，& 操作的结果就是将哈希值的⾼位全部归零，只保留低位值。

### HashMap的扩容机制

当键值对数量超过阈值，也就是容量 \* 负载因⼦时。默认负载因子是0.75。初始容量16。

扩容时，HashMap 会创建⼀个新的数组，其容量是原来的两倍。然后遍历旧哈希表中的元素，将其重新分配到新 的哈希表中。

如果当前桶中只有⼀个元素，那么直接通过键的哈希值与数组⼤⼩取模锁定新的索引位置： e.hash & (newCap - 1) 。 如果当前桶是红⿊树，那么会调⽤ split() ⽅法分裂树节点，以保证树的平衡。&#x20;

如果当前桶是链表，会通过旧键的哈希值与旧的数组⼤⼩取模 (e.hash & oldCap) == 0 来作为判断条件，如果 条件为真，元素保留在原索引的位置；否则元素移动到原索引 + 旧数组⼤⼩的位置。

### HashMap是线程安全的吗？

HashMap不是线程安全的，可能会发生这些问题：

* 多线程下扩容死循环。JDK1.7 中的 HashMap 使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。因此，JDK1.8 使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。

* 多线程的 put 可能导致元素的丢失。多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个 key 被后一个 key 覆盖，从而导致元素的丢失。此问题在 JDK 1.7 和 JDK 1.8 中都存在。

* put 和 get 并发时，可能导致 get 为 null。线程 1 执行 put 时，因为元素个数超出 threshold 而导致 rehash，线程 2 此时执行 get，有可能导致这个问题。这个问题在 JDK 1.7 和 JDK 1.8 中都存在。

### 解决 HashMap 线程不安全的问题?

Java 中有 HashTable、Collections.synchronizedMap、以及 ConcurrentHashMap 可以实现线程安全的 Map。

* HashTable 是直接在操作方法上加 synchronized 关键字，锁住整个table数组，粒度比较大；

* Collections.synchronizedMap 是使用 Collections 集合工具的内部类，通过传入 Map 封装出一个 SynchronizedMap 对象，内部定义了一个对象锁，方法内通过对象锁实现；

* ConcurrentHashMap 在jdk1.7中使用分段锁，在jdk1.8中使用CAS+synchronized。



### HashMap内部节点是否有序？

HashMap是无序的，根据 hash 值随机插入。如果想使用有序的Map，可以使用LinkedHashMap 或者 TreeMap。

### LinkedHashMap 怎么实现有序的？

LinkedHashMap 在 HashMap 的基础上维护了⼀个双向链表，通过 before 和 after 标识前置节点和后置节点。

从⽽实现插⼊的顺序或访问顺序。

### &#x20;TreeMap 怎么实现有序的？

TreeMap 通过 key 的⽐较器来决定元素的顺序，如果没有指定⽐较器，那么 key 必须实现 Comparable 接⼝。

TreeMap 的底层是红⿊树，红⿊树是⼀种⾃平衡的⼆叉查找树，每个节点都⼤于其左⼦树中的任何节点，⼩于其 右⼦节点树种的任何节点。

插⼊或者删除元素时通过旋转和染⾊来保持树的平衡。 查找的时候从根节点开始，利⽤⼆叉查找树的特点，逐步向左⼦树或者右⼦树递归查找，直到找到⽬标元素。

### TreeMap 和 HashMap 的区别

①、HashMap 是基于数组+链表+红⿊树实现的，put 元素的时候会先计算 key 的哈希值，然后通过哈希值计算出 元素在数组中的存放下标，然后将元素插⼊到指定的位置，如果发⽣哈希冲突，会使⽤链表来解决，如果链表⻓度 ⼤于 8，会转换为红⿊树。&#x20;

②、TreeMap 是基于红⿊树实现的，put 元素的时候会先判断根节点是否为空，如果为空，直接插⼊到根节点， 如果不为空，会通过 key 的⽐较器来判断元素应该插⼊到左⼦树还是右⼦树。&#x20;

在没有发⽣哈希冲突的情况下，HashMap 的查找效率是 O(1) 。适⽤于查找操作⽐较频繁的场景。 TreeMap 的查找效率是 O(logn) 。并且保证了元素的顺序，因此适⽤于需要⼤量范围查找或者有序遍历的场景。