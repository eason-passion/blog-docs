# Mysql基础

## 什么是关系型数据库？

关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。

关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。

大部分关系型数据库都支持事务的四大特性(ACID)。

MySQL是一个关系型数据库，它采用表的形式来存储数据,有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。

## 数据库的三大范式

**第一范式1NF**(保证原子性)

确保数据库表字段的原子性。如果一个表中的“地址”列包含了省、市和具体地址，这不符合1NF，因为“地址”可以继续拆分成更细致的部分。按1NF要求，应该将“地址”拆分为“省份”、“城市”和“具体地址”等列。

**第二范式2NF**(消除部分依赖)

首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。例如，在学生成绩表中，如果学号和课程编号组成联合主键，那么成绩这一非主键列应同时依赖于学号和课程编号，而不是仅依赖于其中之一。

**第三范式3NF（消除传递依赖）**

首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。例如，如果一个表中包含学生信息和院校信息，其中学生所在院校依赖于学号，而院校地址和电话又依赖于所在院校，这就形成了传递依赖。按照3NF的要求，需要将表拆分为学生表和院校表，使每个属性都直接依赖于主键。

## Mysql的架构/组成

MySQL主要分为 Server 层和存储引擎层：

* **Server 层**：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。

* **存储引擎**： 实现数据的存储和提取，不同的存储引擎如InnoDB、MyISAM通过这些API与Server层交互。存储引擎层提供数据存储和提取的具体实现，而Server层通过API调用这些功能，使得不同存储引擎能够与Server层无缝对接。

**Server 层基本组件**

* **连接器：** 负责与客户端建立连接，并管理连接的权限验证和维持。当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。

* **查询缓存:** 执行查询语句的时候，会先查询缓存，先校验这个 select语句 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。

* **分析器:** 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析。首先通过词法分析识别出各个字符串的意义，然后进行语法分析，检查语句是否符合语法结构。如有错误，会提示错误位置。

* **优化器：** 优化器对查询进行优化，选择最有效的查询路径，包括索引的选择和表的读取顺序，生成执行计划，包括选择合适的索引、表扫描顺序等。

* **执行器：** 根据优化后的执行计划调用存储引擎的API来实际执行SQL语句。在执行前会再次检查权限，确认当前用户有权执行该操作，然后通过存储引擎接口访问数据。

## sql语句在Mysql中的执行过程

其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）

### 1.查询语句执行流程

大概有4步：

* 先连接器检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接返回缓存结果，如果没有，执行下一步。

* 通过分析器进行词法分析，提取 SQL 语句的关键元素。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。

* 接下来就是优化器进行确定执行方案，优化器根据自己的优化算法进行选择执行效率最好的一个方案

* 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

### 2.更新语句执行流程

举个例子，更新语句是这样的：

update user set name = 'name' where id = 1;

1.先查询到 id 为1的记录，有缓存会使用缓存。

2.拿到查询结果，将 name 更新为张三，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录`redo log`，此时`redo log`进入 `准备`状态。

3.执行器收到通知后记录`binlog`，然后调用引擎接口，提交`redo log`为提交状态。

4.更新完成。

**为什么记录完`redo log`，不直接提交，而是先进入`准备`状态？**

假设先写`redo log`直接提交，然后写`binlog`，写完`redo log`后，机器挂了，`binlog`日志没有被写入，那么机器重启后，这台机器会通过`redo log`恢复数据，但是这个时候`binlog`并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。

## inner join,left join和right join的区别

1 Join(Inner Join) **内连接** 查出两表完全匹配的部分。（交集）

2 Left Join 左连接 **返回左表所有的行，右表返回匹配行**，**不匹配的返回NULL**

3 Right Join 右连接 **返回右表所有的行，左表返回匹配行，不匹配的返回NULL**

4 Full Join 全连接 **只要其中一个表存在匹配，则返回行**

## MySQL 是如何保证数据不丢失的？

* 只要**redolog&#x20;**&#x548C;**&#x20;binlog** 保证持久化磁盘就能确保MySQL异常重启后回复数据

* 在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。

## 什么会导致MySQL 自增主键 ID 不连续？

MySQL 自增主键 ID 不连续的原因可能有以下几点：

1. 插入数据失败：当插入数据时，如果某些原因导致插入失败，那么自增 ID 会跳过这个值，导致不连续。

2. 删除数据：当删除某条记录时，自增 ID 不会回退，因此会导致不连续。

3. 事务回滚：在事务中插入数据时，如果发生错误导致事务回滚，那么已经分配的自增 ID 也会被跳过，导致不连续。

4. 数据库备份和恢复：在进行数据库备份和恢复时，可能会涉及到数据的重新分配，导致自增 ID 不连续。

5. 分布式系统：在分布式系统中，多个节点可能同时分配自增 ID，虽然每个节点内部是连续的，但在整个系统中可能会出现不连续的情况。

6. 手动设置自增 ID：如果在插入数据时手动设置了自增 ID，可能会导致不连续。

为了避免**自增 ID 不连续**的问题，可以采取以下措施：

1. 使用 UUID 作为主键，而不是自增 ID。

2. 在不影响性能的前提下，尽量减少事务回滚和数据删除操作。

3. 在分布式系统中，使用全局唯一 ID 生成策略，如雪花算法（Snowflake）等。

## 什么是sql注入？怎么解决？

SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对server端发起的请求参数中植入一些SQL代码，server端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。

**如何解决SQL注入**

* 严格的参数校验

* PreparedStatement预编译防止SQL注入

* PreparedStatement具有预编译功能，以上述SQL为例使用PreparedStatement预编译后的SQL为：此时SQL语句结构已固定，无论"?"被替换为任何参数，SQL语句只认为where后面只有一个条件，当再传入 1001 or 1 = 1时当作一个整体，语句会报错，从而达到防止SQL注入效果。

* mybatis中#{}防止SQL注入

* mybatis中#{}表达式防止SQL注入与PreparedStatement类似，都是对SQL语句进行预编译处理注意：#{} ：参数占位符，可防sql注入

* ${} ：拼接替换符，**不能防止SQL注入**，一般用于传入数据库对象（如：数据库名称、表名）order by 后的条件
