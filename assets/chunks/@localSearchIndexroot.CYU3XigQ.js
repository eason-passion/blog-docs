const t='{"documentCount":182,"nextId":182,"documentIds":{"0":"/blog-docs/about.html#作者","1":"/blog-docs/about.html#一位在校大学生","2":"/blog-docs/api-examples.html#runtime-api-examples","3":"/blog-docs/api-examples.html#results","4":"/blog-docs/api-examples.html#theme-data","5":"/blog-docs/api-examples.html#page-data","6":"/blog-docs/api-examples.html#page-frontmatter","7":"/blog-docs/api-examples.html#more","8":"/blog-docs/backend/Redis/持久化.html#redis的持久化","9":"/blog-docs/backend/Redis/持久化.html#aof日志如何实现","10":"/blog-docs/backend/Redis/持久化.html#rdb快照如何实现","11":"/blog-docs/backend/Redis/持久化.html#混合持久化","12":"/blog-docs/backend/Redis/基础.html#redis基础","13":"/blog-docs/backend/Redis/基础.html#什么是redis","14":"/blog-docs/backend/Redis/基础.html#redis的数据结构","15":"/blog-docs/backend/Redis/基础.html#五种常用数据类型介绍","16":"/blog-docs/backend/Redis/基础.html#zset的底层原理","17":"/blog-docs/backend/Redis/基础.html#什么是跳表","18":"/blog-docs/backend/Redis/基础.html#hash的底层原理","19":"/blog-docs/backend/Redis/基础.html#_3种redis特殊数据类型","20":"/blog-docs/backend/Redis/基础.html#数值范围0-40亿的数如何排序-bitmap","21":"/blog-docs/backend/Redis/基础.html#string-还是-hash-存储对象数据更好呢","22":"/blog-docs/backend/Redis/基础.html#购物车信息用-string-还是-hash-存储更好呢","23":"/blog-docs/backend/Redis/基础.html#使用-redis-实现一个排行榜怎么做","24":"/blog-docs/backend/Redis/基础.html#set-的应用场景是什么","25":"/blog-docs/backend/Redis/基础.html#使用-set-实现抽奖系统怎么做","26":"/blog-docs/backend/Redis/基础.html#使用-bitmap-统计活跃用户怎么做","27":"/blog-docs/backend/Redis/基础.html#什么是hyperloglog-使用-hyperloglog-统计页面-uv-怎么做","28":"/blog-docs/backend/Redis/基础.html#redis怎么实现消息队列","29":"/blog-docs/backend/Redis/基础.html#redis-怎么实现延时队列","30":"/blog-docs/backend/Redis/基础.html#redis常用命令","31":"/blog-docs/backend/Redis/基础.html#字符串操作命令","32":"/blog-docs/backend/Redis/基础.html#setnx命令的原理","33":"/blog-docs/backend/Redis/基础.html#setex命令的原理","34":"/blog-docs/backend/Redis/基础.html#通用命令","35":"/blog-docs/backend/java/List.html#list","36":"/blog-docs/backend/java/List.html#arraylist-和-linkedlist-有什么区别","37":"/blog-docs/backend/java/List.html#arraylist扩容机制","38":"/blog-docs/backend/java/List.html#快速失败fail-fast","39":"/blog-docs/backend/java/List.html#安全失败-fail—safe","40":"/blog-docs/backend/java/List.html#实现-arraylist-线程安全的方法","41":"/blog-docs/backend/java/List.html#arraylist-和-vector-的区别","42":"/blog-docs/backend/java/List.html#copyonwritearraylist-x20","43":"/blog-docs/backend/java/Set.html#set","44":"/blog-docs/backend/java/Set.html#hashset-的底层实现","45":"/blog-docs/backend/java/Set.html#hashset-和-arraylist-的区别","46":"/blog-docs/backend/java/Set.html#hashset-怎么判断元素重复-重复了是否-put","47":"/blog-docs/backend/java/Map.html#map","48":"/blog-docs/backend/java/Map.html#hashmap底层数据结构","49":"/blog-docs/backend/java/Map.html#红黑树","50":"/blog-docs/backend/java/Map.html#红黑树如何保证平衡","51":"/blog-docs/backend/java/Map.html#hashmap为什么要用红黑树-为什么不用二叉树、平衡树","52":"/blog-docs/backend/java/Map.html#hashmap-的-put-流程","53":"/blog-docs/backend/java/Map.html#只重写元素的-equals-方法没重写-hashcode-put-的时候会发生什么","54":"/blog-docs/backend/java/Map.html#hashmap怎么get查找元素","55":"/blog-docs/backend/java/Map.html#hashmap的hash函数","56":"/blog-docs/backend/java/Map.html#为什么hashmap的容量是2的幂次方","57":"/blog-docs/backend/java/Map.html#hashmap的扩容机制","58":"/blog-docs/backend/java/Map.html#hashmap是线程安全的吗","59":"/blog-docs/backend/java/Map.html#解决-hashmap-线程不安全的问题","60":"/blog-docs/backend/java/Map.html#hashmap内部节点是否有序","61":"/blog-docs/backend/java/Map.html#linkedhashmap-怎么实现有序的","62":"/blog-docs/backend/java/Map.html#x20-treemap-怎么实现有序的","63":"/blog-docs/backend/java/Map.html#treemap-和-hashmap-的区别","64":"/blog-docs/backend/java/Stream流.html#stream流","65":"/blog-docs/backend/java/Stream流.html#什么是stream流","66":"/blog-docs/backend/java/反射.html#反射","67":"/blog-docs/backend/java/反射.html#什么是反射","68":"/blog-docs/backend/java/反射.html#反射应用场景","69":"/blog-docs/backend/java/反射.html#反射的优缺点","70":"/blog-docs/backend/java/集合框架.html#常见集合框架","71":"/blog-docs/backend/java/集合框架.html#集合框架常用工具类","72":"/blog-docs/backend/java/集合框架.html#集合类-优劣","73":"/blog-docs/backend/java/集合框架.html#队列和栈","74":"/blog-docs/backend/mysql/mysql的存储引擎.html#存储引擎","75":"/blog-docs/backend/mysql/mysql的存储引擎.html#常见存储引擎","76":"/blog-docs/backend/mysql/mysql的存储引擎.html#myisam-和-innodb-有什么区别","77":"/blog-docs/backend/mysql/mysql的存储引擎.html#行级锁和表级锁","78":"/blog-docs/backend/mysql/mysql的存储引擎.html#行锁有哪几种","79":"/blog-docs/backend/mysql/mysql的存储引擎.html#innodb-数据页结构","80":"/blog-docs/backend/mysql/mysql的存储引擎.html#innodb-为什么要用自增-id-作为主键","81":"/blog-docs/backend/mysql/mysql基础.html#mysql基础","82":"/blog-docs/backend/mysql/mysql基础.html#什么是关系型数据库","83":"/blog-docs/backend/mysql/mysql基础.html#数据库的三大范式","84":"/blog-docs/backend/mysql/mysql基础.html#mysql的架构-组成","85":"/blog-docs/backend/mysql/mysql基础.html#sql语句在mysql中的执行过程","86":"/blog-docs/backend/mysql/mysql基础.html#_1-查询语句执行流程","87":"/blog-docs/backend/mysql/mysql基础.html#_2-更新语句执行流程","88":"/blog-docs/backend/mysql/mysql基础.html#inner-join-left-join和right-join的区别","89":"/blog-docs/backend/mysql/mysql基础.html#mysql-是如何保证数据不丢失的","90":"/blog-docs/backend/mysql/mysql基础.html#什么会导致mysql-自增主键-id-不连续","91":"/blog-docs/backend/mysql/mysql基础.html#什么是sql注入-怎么解决","92":"/blog-docs/backend/java/java基础.html#面向对象基础","93":"/blog-docs/backend/java/java基础.html#面向对象和面向过程的区别","94":"/blog-docs/backend/java/java基础.html#创建一个对象用什么运算符-对象实体与对象引用有何不同","95":"/blog-docs/backend/java/java基础.html#对象的相等和引用相等的区别","96":"/blog-docs/backend/java/java基础.html#方法重载和重写的区别","97":"/blog-docs/backend/java/java基础.html#构造方法有哪些特点-是否可被-override","98":"/blog-docs/backend/java/java基础.html#面向对象三大特性","99":"/blog-docs/backend/java/java基础.html#封装","100":"/blog-docs/backend/java/java基础.html#继承","101":"/blog-docs/backend/java/java基础.html#多态","102":"/blog-docs/backend/java/java基础.html#接口和抽象类有什么共同点和区别","103":"/blog-docs/backend/java/java基础.html#深拷贝和浅拷贝区别了解吗-什么是引用拷贝","104":"/blog-docs/backend/java/java基础.html#什么是深拷贝和浅拷贝","105":"/blog-docs/backend/java/java基础.html#java基础知识","106":"/blog-docs/backend/java/java基础.html#什么是值传递和引用传递","107":"/blog-docs/backend/java/java基础.html#c-和java的区别","108":"/blog-docs/backend/java/java基础.html#java关键字和保留字","109":"/blog-docs/backend/java/java基础.html#java的特点","110":"/blog-docs/backend/java/java基础.html#java是如何实现跨平台的","111":"/blog-docs/backend/java/java基础.html#为什么说-java-语言-编译与解释并存","112":"/blog-docs/backend/java/java基础.html#jdk-jre-jvm三者的关系","113":"/blog-docs/backend/java/java基础.html#java创建对象有几种方式","114":"/blog-docs/backend/java/java基础.html#说说类实例化的顺序","115":"/blog-docs/backend/java/java基础.html#java的4种引用类型","116":"/blog-docs/backend/java/java基础.html#java数据类型","117":"/blog-docs/backend/java/java基础.html#java的基本数据类型有哪些-每个占多少位","118":"/blog-docs/backend/java/java基础.html#了解java的包装类型吗-为什么需要包装类","119":"/blog-docs/backend/java/java基础.html#自动装箱与拆箱了解吗-原理是什么","120":"/blog-docs/backend/java/java基础.html#为什么浮点数运算的时候会有精度丢失的风险","121":"/blog-docs/backend/java/java基础.html#如何解决浮点数运算的精度丢失问题","122":"/blog-docs/backend/java/java基础.html#包装类型的缓存机制了解么","123":"/blog-docs/backend/java/java基础.html#object","124":"/blog-docs/backend/java/java基础.html#object常用方法有哪些","125":"/blog-docs/backend/java/java基础.html#equals和引用相等-的区别","126":"/blog-docs/backend/java/java基础.html#hashcode-有什么用","127":"/blog-docs/backend/java/java基础.html#为什么要有-hashcode","128":"/blog-docs/backend/java/java基础.html#为什么重写-equals-时一定要重写-hashcode","129":"/blog-docs/backend/java/java基础.html#两个对象的hashcode-相同-则-equals-是否也一定为-true","130":"/blog-docs/backend/java/java基础.html#string","131":"/blog-docs/backend/java/java基础.html#string-stringbuffer-和-stringbuilder区别","132":"/blog-docs/backend/java/java基础.html#string-为什么不可变","133":"/blog-docs/backend/java/java基础.html#为什么string要设计成不可变的","134":"/blog-docs/backend/java/java基础.html#string-equals-和-object-equals-有何区别","135":"/blog-docs/backend/java/java基础.html#什么是字符串常量池","136":"/blog-docs/backend/java/java基础.html#string-s-new-string-abc-会创建几个对象","137":"/blog-docs/backend/java/java基础.html#string-类的常用方法有哪些","138":"/blog-docs/backend/java/java基础.html#异常","139":"/blog-docs/backend/java/java基础.html#exception-和-error-有什么区别","140":"/blog-docs/backend/java/java基础.html#运行时异常-runtimeexception-和非运行时异常-checkedexecption-的区别","141":"/blog-docs/backend/java/java基础.html#throwable-类常用方法有哪些","142":"/blog-docs/backend/java/java基础.html#try-catch-finally-如何使用","143":"/blog-docs/backend/java/java基础.html#java中的finally一定会被执行吗","144":"/blog-docs/backend/java/java基础.html#throw和throws的区别","145":"/blog-docs/backend/java/java基础.html#泛型","146":"/blog-docs/backend/java/java基础.html#代理","147":"/blog-docs/backend/java/java基础.html#静态代理","148":"/blog-docs/backend/java/java基础.html#动态代理","149":"/blog-docs/backend/java/java基础.html#_1-jdk动态代理","150":"/blog-docs/backend/java/java基础.html#_2-cglib动态代理","151":"/blog-docs/backend/java/java基础.html#_3-静态代理和动态代理的对比","152":"/blog-docs/backend/java/java基础.html#序列化与反序列化","153":"/blog-docs/backend/java/java基础.html#什么是序列化-什么是反序列化","154":"/blog-docs/backend/java/java基础.html#常见应用场景","155":"/blog-docs/backend/java/java基础.html#如果有些字段不想进行序列化怎么办-transient关键字","156":"/blog-docs/backend/java/java基础.html#实现序列化和反序列化为什么要实现-serializable-接口","157":"/blog-docs/backend/java/java基础.html#static-属性为什么不会被序列化","158":"/blog-docs/backend/java/java基础.html#i-o流","159":"/blog-docs/backend/java/java基础.html#java-io-流了解吗","160":"/blog-docs/backend/java/java基础.html#i-o-流为什么要分为字节流和字符流呢","161":"/blog-docs/backend/mysql/日志.html#日志","162":"/blog-docs/backend/mysql/日志.html#bin-log-redo-log-undo-log日志","163":"/blog-docs/backend/mysql/日志.html#它们是什么","164":"/blog-docs/backend/mysql/日志.html#undo-log-与redo-log的区别","165":"/blog-docs/backend/mysql/日志.html#bin-log和redo-log有什么区别","166":"/blog-docs/backend/mysql/日志.html#redo-log-的执行流程","167":"/blog-docs/backend/mysql/日志.html#为什么-redo-log-具有-crash-safe-的能力-是-binlog-无法替代的","168":"/blog-docs/bigModel/RAG 概念.html#rag-概念","169":"/blog-docs/bigModel/RAG 概念.html#什么是-rag","170":"/blog-docs/bigModel/RAG 概念.html#rag-工作流程","171":"/blog-docs/bigModel/RAG 概念.html#_1、文档收集和切割","172":"/blog-docs/bigModel/RAG 概念.html#_2、向量转换和存储","173":"/blog-docs/markdown-examples.html#markdown-extension-examples","174":"/blog-docs/markdown-examples.html#syntax-highlighting","175":"/blog-docs/markdown-examples.html#custom-containers","176":"/blog-docs/markdown-examples.html#more","177":"/blog-docs/学习路线.html#java-后端开发工程师零基础入门学习路线","178":"/blog-docs/学习路线.html#一、阶段一-java-基础语法与核心特性-0-4-周","179":"/blog-docs/学习路线.html#一-核心知识点","180":"/blog-docs/学习路线.html#开发环境搭建","181":"/blog-docs/学习路线.html#二-学习资源推荐"},"fieldIds":{"title":0,"titles":1,"text":2},"fieldLength":{"0":[1,1,1],"1":[1,1,1],"2":[3,1,51],"3":[1,3,1],"4":[2,4,2],"5":[2,4,2],"6":[2,4,2],"7":[1,3,11],"8":[1,1,22],"9":[2,1,171],"10":[2,1,114],"11":[1,1,76],"12":[1,1,1],"13":[1,1,44],"14":[1,1,70],"15":[1,2,31],"16":[1,3,42],"17":[2,4,42],"18":[1,3,38],"19":[1,2,67],"20":[4,3,23],"21":[5,2,21],"22":[6,2,27],"23":[4,2,18],"24":[3,2,34],"25":[4,2,17],"26":[4,2,34],"27":[7,2,86],"28":[2,2,12],"29":[2,2,6],"30":[1,1,1],"31":[1,2,18],"32":[1,3,23],"33":[1,3,23],"34":[1,2,17],"35":[1,1,1],"36":[5,1,72],"37":[1,1,13],"38":[2,1,44],"39":[4,1,25],"40":[3,1,17],"41":[4,1,16],"42":[3,1,14],"43":[1,1,1],"44":[3,1,18],"45":[4,1,25],"46":[4,1,11],"47":[1,1,1],"48":[1,1,25],"49":[1,1,13],"50":[2,1,3],"51":[4,1,15],"52":[4,1,43],"53":[7,1,17],"54":[2,1,11],"55":[2,1,24],"56":[2,1,37],"57":[1,1,39],"58":[2,1,49],"59":[4,1,26],"60":[2,1,9],"61":[3,1,11],"62":[4,1,20],"63":[4,1,35],"64":[1,1,1],"65":[1,1,23],"66":[1,1,1],"67":[1,1,13],"68":[1,1,30],"69":[2,1,50],"70":[1,1,30],"71":[1,1,17],"72":[3,1,29],"73":[1,1,35],"74":[1,1,1],"75":[1,1,30],"76":[5,1,41],"77":[1,6,30],"78":[2,6,41],"79":[2,1,29],"80":[5,1,17],"81":[1,1,1],"82":[2,1,28],"83":[1,1,49],"84":[2,1,64],"85":[1,1,9],"86":[2,2,28],"87":[2,2,50],"88":[5,1,23],"89":[3,1,19],"90":[5,1,48],"91":[3,1,45],"92":[1,1,1],"93":[2,1,7],"94":[3,1,19],"95":[1,1,3],"96":[2,1,15],"97":[4,1,16],"98":[1,1,5],"99":[1,2,6],"100":[1,2,8],"101":[1,2,16],"102":[2,1,37],"103":[3,1,1],"104":[2,4,20],"105":[1,1,1],"106":[2,1,13],"107":[1,1,53],"108":[1,1,181],"109":[1,1,34],"110":[2,1,22],"111":[5,1,44],"112":[3,1,64],"113":[2,1,13],"114":[1,1,7],"115":[1,1,40],"116":[1,1,1],"117":[3,1,22],"118":[3,1,37],"119":[3,1,12],"120":[2,1,10],"121":[2,3,9],"122":[2,1,22],"123":[1,1,1],"124":[2,1,38],"125":[1,1,10],"126":[3,1,7],"127":[3,1,30],"128":[5,1,19],"129":[7,1,17],"130":[1,1,1],"131":[4,1,20],"132":[3,1,26],"133":[2,3,42],"134":[6,1,10],"135":[2,1,17],"136":[8,1,12],"137":[3,1,26],"138":[1,1,1],"139":[5,1,41],"140":[6,1,17],"141":[3,1,19],"142":[5,1,21],"143":[2,1,20],"144":[2,1,19],"145":[1,1,13],"146":[1,1,12],"147":[1,1,38],"148":[1,1,17],"149":[2,2,12],"150":[2,2,19],"151":[2,2,21],"152":[1,1,1],"153":[3,1,13],"154":[1,1,17],"155":[3,1,17],"156":[4,1,11],"157":[3,1,7],"158":[2,1,1],"159":[4,2,34],"160":[4,2,21],"161":[1,1,1],"162":[5,1,1],"163":[2,6,40],"164":[4,6,25],"165":[4,6,23],"166":[4,6,71],"167":[11,6,56],"168":[2,1,1],"169":[3,2,32],"170":[2,2,10],"171":[2,3,27],"172":[2,3,9],"173":[3,1,14],"174":[2,3,26],"175":[2,3,21],"176":[1,3,11],"177":[2,1,1],"178":[8,2,1],"179":[3,9,1],"180":[1,9,87],"181":[3,2,342]},"averageFieldLength":[2.467032967032967,1.664835164835165,26.22527472527473],"storedFields":{"0":{"title":"作者","titles":[]},"1":{"title":"一位在校大学生","titles":["作者"]},"2":{"title":"Runtime API Examples","titles":[]},"3":{"title":"Results","titles":["Runtime API Examples"]},"4":{"title":"Theme Data","titles":["Runtime API Examples","Results"]},"5":{"title":"Page Data","titles":["Runtime API Examples","Results"]},"6":{"title":"Page Frontmatter","titles":["Runtime API Examples","Results"]},"7":{"title":"More","titles":["Runtime API Examples"]},"8":{"title":"Redis的持久化","titles":[]},"9":{"title":"AOF日志如何实现？","titles":["Redis的持久化"]},"10":{"title":"RDB快照如何实现？","titles":["Redis的持久化"]},"11":{"title":"混合持久化","titles":["Redis的持久化"]},"12":{"title":"Redis基础","titles":[]},"13":{"title":"什么是Redis","titles":["Redis基础"]},"14":{"title":"Redis的数据结构","titles":["Redis基础"]},"15":{"title":"五种常用数据类型介绍","titles":["Redis基础","Redis的数据结构"]},"16":{"title":"Zset的底层原理","titles":["Redis基础","Redis的数据结构","五种常用数据类型介绍"]},"17":{"title":"什么是跳表？","titles":["Redis基础","Redis的数据结构","五种常用数据类型介绍","Zset的底层原理"]},"18":{"title":"Hash的底层原理","titles":["Redis基础","Redis的数据结构","五种常用数据类型介绍"]},"19":{"title":"3种redis特殊数据类型","titles":["Redis基础","Redis的数据结构"]},"20":{"title":"数值范围0-40亿的数如何排序(bitmap)","titles":["Redis基础","Redis的数据结构","3种redis特殊数据类型"]},"21":{"title":"String 还是 Hash 存储对象数据更好呢？","titles":["Redis基础","Redis的数据结构"]},"22":{"title":"购物车信息用 String 还是 Hash 存储更好呢?","titles":["Redis基础","Redis的数据结构"]},"23":{"title":"使用 Redis 实现一个排行榜怎么做？","titles":["Redis基础","Redis的数据结构"]},"24":{"title":"Set 的应用场景是什么？","titles":["Redis基础","Redis的数据结构"]},"25":{"title":"使用 Set 实现抽奖系统怎么做？","titles":["Redis基础","Redis的数据结构"]},"26":{"title":"使用 Bitmap 统计活跃用户怎么做？","titles":["Redis基础","Redis的数据结构"]},"27":{"title":"什么是HyperLogLog ？使用 HyperLogLog 统计页面 UV 怎么做？","titles":["Redis基础","Redis的数据结构"]},"28":{"title":"redis怎么实现消息队列？","titles":["Redis基础","Redis的数据结构"]},"29":{"title":"Redis 怎么实现延时队列","titles":["Redis基础","Redis的数据结构"]},"30":{"title":"Redis常用命令","titles":["Redis基础"]},"31":{"title":"字符串操作命令","titles":["Redis基础","Redis常用命令"]},"32":{"title":"setnx命令的原理","titles":["Redis基础","Redis常用命令","字符串操作命令"]},"33":{"title":"setex命令的原理","titles":["Redis基础","Redis常用命令","字符串操作命令"]},"34":{"title":"通用命令","titles":["Redis基础","Redis常用命令"]},"35":{"title":"List","titles":[]},"36":{"title":"ArrayList 和 LinkedList 有什么区别？","titles":["List"]},"37":{"title":"ArrayList扩容机制","titles":["List"]},"38":{"title":"快速失败fail-fast","titles":["List"]},"39":{"title":"安全失败（fail—safe）","titles":["List"]},"40":{"title":"实现 ArrayList 线程安全的方法","titles":["List"]},"41":{"title":"ArrayList 和 Vector 的区别","titles":["List"]},"42":{"title":"CopyOnWriteArrayList&#x20;","titles":["List"]},"43":{"title":"Set","titles":[]},"44":{"title":"HashSet 的底层实现?","titles":["Set"]},"45":{"title":"HashSet 和 ArrayList 的区别","titles":["Set"]},"46":{"title":"HashSet 怎么判断元素重复，重复了是否 put","titles":["Set"]},"47":{"title":"Map","titles":[]},"48":{"title":"HashMap底层数据结构","titles":["Map"]},"49":{"title":"红黑树","titles":["Map"]},"50":{"title":"红黑树如何保证平衡？","titles":["Map"]},"51":{"title":"HashMap为什么要用红黑树，为什么不用二叉树、平衡树？","titles":["Map"]},"52":{"title":"HashMap 的 put 流程","titles":["Map"]},"53":{"title":"只重写元素的 equals ⽅法没重写 hashCode，put 的时候会发生什么?","titles":["Map"]},"54":{"title":"HashMap怎么get查找元素？","titles":["Map"]},"55":{"title":"HashMap的hash函数？","titles":["Map"]},"56":{"title":"为什么HashMap的容量是2的幂次方？","titles":["Map"]},"57":{"title":"HashMap的扩容机制","titles":["Map"]},"58":{"title":"HashMap是线程安全的吗？","titles":["Map"]},"59":{"title":"解决 HashMap 线程不安全的问题?","titles":["Map"]},"60":{"title":"HashMap内部节点是否有序？","titles":["Map"]},"61":{"title":"LinkedHashMap 怎么实现有序的？","titles":["Map"]},"62":{"title":"&#x20;TreeMap 怎么实现有序的？","titles":["Map"]},"63":{"title":"TreeMap 和 HashMap 的区别","titles":["Map"]},"64":{"title":"Stream流","titles":[]},"65":{"title":"什么是Stream流","titles":["Stream流"]},"66":{"title":"反射","titles":[]},"67":{"title":"什么是反射","titles":["反射"]},"68":{"title":"反射应用场景","titles":["反射"]},"69":{"title":"反射的优缺点？","titles":["反射"]},"70":{"title":"常见集合框架","titles":[]},"71":{"title":"集合框架常用工具类","titles":[]},"72":{"title":"集合类，优劣？","titles":[]},"73":{"title":"队列和栈","titles":[]},"74":{"title":"存储引擎","titles":[]},"75":{"title":"常见存储引擎","titles":["存储引擎"]},"76":{"title":"MyISAM 和 InnoDB 有什么区别？","titles":["存储引擎"]},"77":{"title":"行级锁和表级锁","titles":["存储引擎","MyISAM 和 InnoDB 有什么区别？"]},"78":{"title":"行锁有哪几种？","titles":["存储引擎","MyISAM 和 InnoDB 有什么区别？"]},"79":{"title":"innoDB 数据页结构","titles":["存储引擎"]},"80":{"title":"InnoDB 为什么要用自增 ID 作为主键？","titles":["存储引擎"]},"81":{"title":"Mysql基础","titles":[]},"82":{"title":"什么是关系型数据库？","titles":["Mysql基础"]},"83":{"title":"数据库的三大范式","titles":["Mysql基础"]},"84":{"title":"Mysql的架构/组成","titles":["Mysql基础"]},"85":{"title":"sql语句在Mysql中的执行过程","titles":["Mysql基础"]},"86":{"title":"1.查询语句执行流程","titles":["Mysql基础","sql语句在Mysql中的执行过程"]},"87":{"title":"2.更新语句执行流程","titles":["Mysql基础","sql语句在Mysql中的执行过程"]},"88":{"title":"inner join,left join和right join的区别","titles":["Mysql基础"]},"89":{"title":"MySQL 是如何保证数据不丢失的？","titles":["Mysql基础"]},"90":{"title":"什么会导致MySQL 自增主键 ID 不连续？","titles":["Mysql基础"]},"91":{"title":"什么是sql注入？怎么解决？","titles":["Mysql基础"]},"92":{"title":"面向对象基础","titles":[]},"93":{"title":"面向对象和面向过程的区别？","titles":["面向对象基础"]},"94":{"title":"创建一个对象用什么运算符?对象实体与对象引用有何不同?","titles":["面向对象基础"]},"95":{"title":"对象的相等和引用相等的区别","titles":["面向对象基础"]},"96":{"title":"方法重载和重写的区别？","titles":["面向对象基础"]},"97":{"title":"构造方法有哪些特点？是否可被 override?","titles":["面向对象基础"]},"98":{"title":"面向对象三大特性","titles":["面向对象基础"]},"99":{"title":"封装","titles":["面向对象基础","面向对象三大特性"]},"100":{"title":"继承","titles":["面向对象基础","面向对象三大特性"]},"101":{"title":"多态","titles":["面向对象基础","面向对象三大特性"]},"102":{"title":"接口和抽象类有什么共同点和区别？","titles":["面向对象基础"]},"103":{"title":"深拷贝和浅拷贝区别了解吗？什么是引用拷贝？","titles":["面向对象基础"]},"104":{"title":"什么是深拷贝和浅拷贝?","titles":["面向对象基础","深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"]},"105":{"title":"Java基础知识","titles":[]},"106":{"title":"什么是值传递和引用传递？","titles":["Java基础知识"]},"107":{"title":"c++和java的区别","titles":["Java基础知识"]},"108":{"title":"Java关键字和保留字","titles":["Java基础知识"]},"109":{"title":"Java的特点","titles":["Java基础知识"]},"110":{"title":"Java是如何实现跨平台的？","titles":["Java基础知识"]},"111":{"title":"为什么说 Java 语言“编译与解释并存”？","titles":["Java基础知识"]},"112":{"title":"JDK/JRE/JVM三者的关系","titles":["Java基础知识"]},"113":{"title":"Java创建对象有几种方式？","titles":["Java基础知识"]},"114":{"title":"说说类实例化的顺序","titles":["Java基础知识"]},"115":{"title":"Java的4种引用类型","titles":["Java基础知识"]},"116":{"title":"Java数据类型","titles":[]},"117":{"title":"Java的基本数据类型有哪些？每个占多少位?","titles":["Java数据类型"]},"118":{"title":"了解Java的包装类型吗？为什么需要包装类？","titles":["Java数据类型"]},"119":{"title":"自动装箱与拆箱了解吗？原理是什么？","titles":["Java数据类型"]},"120":{"title":"为什么浮点数运算的时候会有精度丢失的风险？","titles":["Java数据类型"]},"121":{"title":"如何解决浮点数运算的精度丢失问题？","titles":["Java数据类型","为什么浮点数运算的时候会有精度丢失的风险？"]},"122":{"title":"包装类型的缓存机制了解么？","titles":["Java数据类型"]},"123":{"title":"Object","titles":[]},"124":{"title":"Object常用方法有哪些？","titles":["Object"]},"125":{"title":"equals和引用相等==的区别","titles":["Object"]},"126":{"title":"hashCode() 有什么用？","titles":["Object"]},"127":{"title":"为什么要有 hashCode？","titles":["Object"]},"128":{"title":"为什么重写 equals 时一定要重写 hashCode？","titles":["Object"]},"129":{"title":"两个对象的hashCode()相同，则 equals()是否也一定为 true？","titles":["Object"]},"130":{"title":"String","titles":[]},"131":{"title":"String, StringBuffer 和 StringBuilder区别","titles":["String"]},"132":{"title":"String 为什么不可变？","titles":["String"]},"133":{"title":"为什么String要设计成不可变的？","titles":["String","String 为什么不可变？"]},"134":{"title":"String.equals() 和 Object.equals() 有何区别？","titles":["String"]},"135":{"title":"什么是字符串常量池？","titles":["String"]},"136":{"title":"String s = new String(&quot;abc&quot;)会创建几个对象？","titles":["String"]},"137":{"title":"String 类的常用方法有哪些？","titles":["String"]},"138":{"title":"异常","titles":[]},"139":{"title":"Exception 和 Error 有什么区别？","titles":["异常"]},"140":{"title":"运行时异常(RuntimeException)和非运行时异常（checkedExecption）的区别？","titles":["异常"]},"141":{"title":"Throwable 类常用方法有哪些？","titles":["异常"]},"142":{"title":"try-catch-finally 如何使用？","titles":["异常"]},"143":{"title":"Java中的finally一定会被执行吗？","titles":["异常"]},"144":{"title":"throw和throws的区别？","titles":["异常"]},"145":{"title":"泛型","titles":[]},"146":{"title":"代理","titles":[]},"147":{"title":"静态代理","titles":["代理"]},"148":{"title":"动态代理","titles":["代理"]},"149":{"title":"1.JDK动态代理","titles":["代理","动态代理"]},"150":{"title":"2.CGLIB动态代理","titles":["代理","动态代理"]},"151":{"title":"3.静态代理和动态代理的对比","titles":["代理","动态代理"]},"152":{"title":"序列化与反序列化","titles":[]},"153":{"title":"什么是序列化?什么是反序列化?","titles":["序列化与反序列化"]},"154":{"title":"常见应用场景","titles":["序列化与反序列化"]},"155":{"title":"如果有些字段不想进行序列化怎么办？(transient关键字)","titles":["序列化与反序列化"]},"156":{"title":"实现序列化和反序列化为什么要实现 Serializable 接口?","titles":["序列化与反序列化"]},"157":{"title":"static 属性为什么不会被序列化?","titles":["序列化与反序列化"]},"158":{"title":"I/O流","titles":[]},"159":{"title":"Java IO 流了解吗？","titles":["I/O流"]},"160":{"title":"I/O 流为什么要分为字节流和字符流呢?","titles":["I/O流"]},"161":{"title":"日志","titles":[]},"162":{"title":"bin log/redo log/undo log日志","titles":["日志"]},"163":{"title":"它们是什么？","titles":["日志","bin log/redo log/undo log日志"]},"164":{"title":"undo log 与redo log的区别","titles":["日志","bin log/redo log/undo log日志"]},"165":{"title":"bin log和redo log有什么区别？","titles":["日志","bin log/redo log/undo log日志"]},"166":{"title":"redo log 的执行流程?","titles":["日志","bin log/redo log/undo log日志"]},"167":{"title":"为什么 redo log 具有 crash-safe 的能力，是 binlog 无法替代的？","titles":["日志","bin log/redo log/undo log日志"]},"168":{"title":"RAG 概念","titles":[]},"169":{"title":"什么是 RAG？","titles":["RAG 概念"]},"170":{"title":"RAG 工作流程","titles":["RAG 概念"]},"171":{"title":"1、文档收集和切割","titles":["RAG 概念","RAG 工作流程"]},"172":{"title":"2、向量转换和存储","titles":["RAG 概念","RAG 工作流程"]},"173":{"title":"Markdown Extension Examples","titles":[]},"174":{"title":"Syntax Highlighting","titles":["Markdown Extension Examples"]},"175":{"title":"Custom Containers","titles":["Markdown Extension Examples"]},"176":{"title":"More","titles":["Markdown Extension Examples"]},"177":{"title":"Java 后端开发工程师零基础入门学习路线","titles":[]},"178":{"title":"一、阶段一：Java 基础语法与核心特性（0-4 周）","titles":["Java 后端开发工程师零基础入门学习路线"]},"179":{"title":"（一）核心知识点","titles":["Java 后端开发工程师零基础入门学习路线","一、阶段一：Java 基础语法与核心特性（0-4 周）"]},"180":{"title":"开发环境搭建","titles":["Java 后端开发工程师零基础入门学习路线","一、阶段一：Java 基础语法与核心特性（0-4 周）","（一）核心知识点"]},"181":{"title":"（二）学习资源推荐","titles":["Java 后端开发工程师零基础入门学习路线"]}},"dirtCount":0,"index":[["尝试",{"2":{"181":1}}],["拓展学习",{"2":{"181":1}}],["示例",{"2":{"181":1}}],["复盘与拓展",{"2":{"181":1}}],["复杂查询",{"2":{"181":1}}],["部署尝试",{"2":{"181":1}}],["部分",{"2":{"181":1}}],["严格遵循",{"2":{"181":1}}],["严格的参数校验",{"2":{"91":1}}],["绘制简单流程图",{"2":{"181":1}}],["梳理功能模块",{"2":{"181":1}}],["需求分析",{"2":{"181":1}}],["需要由具体的子类或实现类来进行实例化",{"2":{"102":1}}],["需要将表拆分为学生表和院校表",{"2":{"83":1}}],["需要事务支持",{"2":{"75":1}}],["需要旋转的次数更多",{"2":{"51":1}}],["需要存储前驱和后继",{"2":{"36":1}}],["需要遍历链表",{"2":{"36":1}}],["需要随机获取数据源中的元素的场景",{"2":{"24":1}}],["需要获取多个数据源交集",{"2":{"24":1}}],["需要高效操作的环境",{"2":{"16":1}}],["需要全量把日志都执行一遍",{"2":{"10":1}}],["需要通过加锁来保证数据的安全",{"2":{"9":1}}],["需要读",{"2":{"9":1}}],["现代开发主流",{"2":{"181":1}}],["现代开发中逐渐弱化",{"2":{"181":1}}],["替代",{"2":{"181":1}}],["权限控制",{"2":{"181":1}}],["电商后台管理系统",{"2":{"181":1}}],["电话和姓名排序等",{"2":{"14":1}}],["评论互动",{"2":{"181":1}}],["评论表",{"2":{"181":1}}],["登录",{"2":{"181":1}}],["登录态",{"2":{"181":1}}],["串联所有知识",{"2":{"181":1}}],["五",{"2":{"181":1}}],["五种常用数据类型介绍",{"0":{"15":1},"1":{"16":1,"17":1,"18":1}}],["五种常见的数据结构",{"2":{"14":1}}],["订单流程",{"2":{"181":1}}],["订单趋势",{"2":{"181":1}}],["订阅号推荐",{"2":{"24":1}}],["订阅模式",{"2":{"13":1}}],["给",{"2":{"181":1}}],["给开发者更多优化的空间",{"2":{"107":1}}],["狂神说",{"2":{"181":1}}],["索引",{"2":{"181":1}}],["索引优化",{"2":{"181":1}}],["选读",{"2":{"181":1}}],["选择",{"2":{"180":1,"181":1}}],["选择最有效的查询路径",{"2":{"84":1}}],["选择合适的锁策略取决于具体的工作负载和性能需求",{"2":{"77":1}}],["非必须但可拓展视野",{"2":{"181":1}}],["非主键列",{"2":{"83":2}}],["悲观锁实践",{"2":{"181":1}}],["乐观锁",{"2":{"181":1}}],["子查询",{"2":{"181":1}}],["子进程会把该副本数据写入",{"2":{"10":1}}],["子进程会读取数据库里的所有数据",{"2":{"9":1}}],["子进程互相不影响",{"2":{"10":1}}],["子进程之后开始使用",{"2":{"9":1}}],["子进程带有主进程的数据副本",{"2":{"9":1}}],["联表查询",{"2":{"181":1}}],["四",{"2":{"181":1}}],["合并",{"2":{"181":1}}],["模仿",{"2":{"181":1}}],["模式",{"2":{"181":1}}],["模拟",{"2":{"181":1}}],["模型将文本块转换为高维向量表示",{"2":{"172":1}}],["仓库",{"2":{"181":1}}],["仓库初始化",{"2":{"181":1}}],["廖雪峰",{"2":{"181":1}}],["教程",{"2":{"181":3}}],["指南",{"2":{"181":1}}],["指定元素排名",{"2":{"23":1}}],["堆栈信息定位问题",{"2":{"181":1}}],["断点调试",{"2":{"181":1}}],["驱动等",{"2":{"181":1}}],["工程",{"2":{"181":1}}],["工具链与工程化",{"2":{"181":1}}],["工作流程",{"0":{"170":1},"1":{"171":1,"172":1}}],["工作当中",{"2":{"27":1}}],["练习外键关联",{"2":{"181":1}}],["博客系统",{"2":{"181":1}}],["设计",{"2":{"181":1}}],["设置指定key的值",{"2":{"31":2}}],["设置了一个",{"2":{"9":1}}],["含简单前端页面",{"2":{"181":1}}],["功能",{"2":{"181":3}}],["项目实战与总结",{"2":{"181":1}}],["项目改造为",{"2":{"181":1}}],["项目构建与依赖管理",{"2":{"181":1}}],["项目",{"2":{"181":1}}],["搭建基础",{"2":{"181":1}}],["短小精悍",{"2":{"181":1}}],["必知必会",{"2":{"181":1}}],["必须进行处理",{"2":{"140":1}}],["必须处理",{"2":{"139":1}}],["必须要经过jvm的翻译才能执行",{"2":{"110":1}}],["必须实现",{"2":{"62":1}}],["黑马程序员",{"2":{"181":1}}],["黑树有两种方式保持平衡",{"2":{"50":1}}],["框架",{"2":{"181":1}}],["框架整合实战",{"2":{"181":1}}],["框架教程",{"2":{"181":1}}],["框架文档",{"2":{"181":1}}],["框架核心",{"2":{"181":1}}],["管理依赖",{"2":{"181":1}}],["管理",{"2":{"181":1}}],["初体验",{"2":{"181":1}}],["初始容量16",{"2":{"57":1}}],["初始化bitmap",{"2":{"20":1}}],["了解基础运维",{"2":{"181":1}}],["了解",{"2":{"181":2}}],["了解动态页面渲染",{"2":{"181":1}}],["了解java的包装类型吗",{"0":{"118":1}}],["入门",{"2":{"181":1}}],["入门到实战",{"2":{"181":1}}],["状态码",{"2":{"181":1}}],["状态为",{"2":{"89":1}}],["响应流程",{"2":{"181":1}}],["请求参数获取",{"2":{"181":1}}],["请求头",{"2":{"181":1}}],["请求",{"2":{"181":1}}],["协议",{"2":{"181":1}}],["阶段五",{"2":{"181":1}}],["阶段四",{"2":{"181":1}}],["阶段三",{"2":{"181":1}}],["阶段二",{"2":{"181":1}}],["阶段一",{"0":{"178":1},"1":{"179":1,"180":1}}],["命名好习惯",{"2":{"181":1}}],["命令行计算器",{"2":{"181":1}}],["命令将设置其值",{"2":{"32":1}}],["命令将不执行任何操作",{"2":{"32":1}}],["命令的时候",{"2":{"10":1}}],["命令",{"2":{"10":4,"23":1,"181":1}}],["养成注释",{"2":{"181":1}}],["泰山版",{"2":{"181":1}}],["阿里巴巴",{"2":{"181":1}}],["增删改查",{"2":{"181":2}}],["增加",{"2":{"38":1,"85":1}}],["增加了",{"2":{"10":1}}],["控制台版",{"2":{"181":1}}],["控制写回硬盘的时机",{"2":{"9":1}}],["学习重点",{"2":{"181":1}}],["学习",{"2":{"181":1}}],["学习资源推荐",{"0":{"181":1},"2":{"181":3}}],["学生信息管理系统",{"2":{"181":1}}],["三",{"2":{"181":6}}],["官方文档",{"2":{"181":2}}],["官方手册",{"2":{"181":1}}],["官方指南",{"2":{"181":1}}],["官方",{"2":{"181":1}}],["慕课网",{"2":{"181":3}}],["零基础教程",{"2":{"181":1}}],["尚硅谷",{"2":{"181":1}}],["站",{"2":{"181":3}}],["趣味入门",{"2":{"181":1}}],["卷",{"2":{"181":1}}],["书籍",{"2":{"181":1}}],["区别与使用",{"2":{"180":1}}],["逻辑",{"2":{"180":1}}],["算术",{"2":{"180":1}}],["理解编译",{"2":{"180":1}}],["理解不同类型行锁的特点和适用场景",{"2":{"78":1}}],["推荐过渡学习",{"2":{"181":1}}],["推荐",{"2":{"180":1}}],["社区版",{"2":{"180":1}}],["安装",{"2":{"181":1}}],["安装与环境变量配置",{"2":{"180":1}}],["安全限制",{"2":{"69":1}}],["安全失败",{"0":{"39":1}}],["核心技术",{"2":{"181":1}}],["核心知识点",{"0":{"179":1},"1":{"180":1},"2":{"181":3}}],["核心类库",{"2":{"112":2}}],["周",{"0":{"178":1},"1":{"179":1,"180":1},"2":{"181":4}}],["```",{"2":{"174":1}}],["切割",{"2":{"171":1}}],["切片集群模式",{"2":{"13":1}}],["章节",{"2":{"171":1}}],["俗称",{"2":{"171":1}}],["清洗",{"2":{"171":1}}],["清空购物车直接删除对应的",{"2":{"22":1}}],["收集原始文档",{"2":{"171":1}}],["技术栈",{"2":{"181":2}}],["技术实现主要包含以下",{"2":{"170":1}}],["技术改造后",{"2":{"169":1}}],["准确回答关于特定内容的问题",{"2":{"169":1}}],["准备状态",{"2":{"87":1}}],["回答问题前先查一查特定的知识库来获取知识",{"2":{"169":1}}],["回滚日志",{"2":{"163":1}}],["回滚和崩溃修复能力",{"2":{"76":1}}],["让我们分步来学习",{"2":{"170":1}}],["让",{"2":{"169":1}}],["让代码更简洁",{"2":{"65":1}}],["小抄本",{"2":{"169":1}}],["小于",{"2":{"78":1}}],["配置",{"2":{"180":1,"181":3}}],["配了一个",{"2":{"169":1}}],["配合使用",{"2":{"108":1}}],["检索增强生成",{"2":{"169":1}}],["检查语句是否符合语法结构",{"2":{"84":1}}],["检查给定",{"2":{"34":1}}],["概念",{"0":{"168":1},"1":{"169":1,"170":1,"171":1,"172":1}}],["说明此次操作失败",{"2":{"167":2}}],["说说类实例化的顺序",{"0":{"114":1}}],["拥有全量的日志",{"2":{"167":1}}],["想要恢复未刷盘但已经写入",{"2":{"167":1}}],["哪些数据还没有",{"2":{"167":2}}],["找到未完成的事务",{"2":{"166":1}}],["事务",{"2":{"181":1}}],["事务与锁",{"2":{"181":1}}],["事务也不可能提交",{"2":{"167":2}}],["事务也可以正常提交",{"2":{"166":1}}],["事务回滚",{"2":{"90":1}}],["防止系统崩溃导致的数据丢失",{"2":{"165":1}}],["防止sql注入",{"2":{"91":1}}],["若执行update",{"2":{"163":1}}],["仍能把事务中变更的数据持久化到磁盘上",{"2":{"163":1}}],["问题本质想问",{"2":{"160":1}}],["前后端参数交互",{"2":{"181":1}}],["前后指针",{"2":{"72":1}}],["前者是字节输出流",{"2":{"159":1}}],["前者是字节输入流",{"2":{"159":1}}],["远程主机",{"2":{"159":1}}],["输入和输出",{"2":{"159":1}}],["输出所有标记为1的位置对应的数值",{"2":{"20":1}}],["型的是",{"2":{"155":1}}],["之前需要用到序列化",{"2":{"154":1}}],["之前需要先被序列化",{"2":{"154":1}}],["之前版本了",{"2":{"11":1}}],["下面将从多个维度详细对比bin",{"2":{"165":1}}],["下面将从多个维度详细对比这两种日志",{"2":{"164":1}}],["下面是序列化和反序列化常见应用场景",{"2":{"154":1}}],["下次需要创建同样的对象时",{"2":{"133":1}}],["反之输出到外部存储",{"2":{"159":1}}],["反序列化",{"2":{"153":1}}],["反射代码破坏了抽象性",{"2":{"69":1}}],["反射操作的效率要比那些非反射操作低得多",{"2":{"69":1}}],["反射涉及了动态类型的解析",{"2":{"69":1}}],["反射的缺点",{"2":{"69":1}}],["反射的优点",{"2":{"69":1}}],["反射的优缺点",{"0":{"69":1}}],["反射的性能也要稍差点",{"2":{"69":1}}],["反射让我们在运行时有了分析操作类的能力的同时",{"2":{"69":1}}],["反射可以让我们的代码更加灵活",{"2":{"69":1}}],["反射应用场景",{"0":{"68":1}}],["反射",{"0":{"66":1},"1":{"67":1,"68":1,"69":1},"2":{"67":1}}],["序列化",{"2":{"153":1}}],["序列化与反序列化",{"0":{"152":1},"1":{"153":1,"154":1,"155":1,"156":1,"157":1}}],["灵活性",{"2":{"151":1}}],["目标项目",{"2":{"181":1}}],["目标对象和代理对象都要进行修改",{"2":{"151":1}}],["目标对象与代理类都要同时修改",{"2":{"147":1}}],["目标类不需要实现特定的接口",{"2":{"150":1}}],["目标类必须有实现的接口",{"2":{"149":1}}],["角度来说",{"2":{"148":1}}],["新建多个代理类",{"2":{"147":1}}],["新的类继承父类的属性和行为",{"2":{"100":1}}],["新的",{"2":{"9":3}}],["扩展目标对象的功能",{"2":{"146":1}}],["扩容的时候有可能导致环形链表的出现",{"2":{"58":1}}],["扩容时",{"2":{"57":1}}],["声明的类型参数在使⽤时⽤具体的类型来替换",{"2":{"145":1}}],["声明构造函数",{"2":{"97":1}}],["允许在定义类和接口的时候使⽤类型参数",{"2":{"145":1}}],["允许重复元素和",{"2":{"45":1}}],["泛型可以很好的解决这个问题",{"2":{"145":1}}],["泛型最⼤的好处是可以提⾼代码的复⽤性",{"2":{"145":1}}],["泛型",{"0":{"145":1}}],["泛型参数的安全检查发生在编译时",{"2":{"69":1}}],["抛出的是异常对象",{"2":{"144":1}}],["突然宕机了",{"2":{"143":1}}],["捕获到的异常",{"2":{"142":1}}],["属于程序无法处理的错误",{"2":{"139":1}}],["属性优先于对象存在",{"2":{"157":1}}],["属性为什么不会被序列化",{"0":{"157":1}}],["属性",{"2":{"68":1}}],["受检查异常",{"2":{"139":1}}],["又可以分为",{"2":{"139":1}}],["又降低数据丢失风险",{"2":{"11":1}}],["截取字符串",{"2":{"137":1}}],["去除字符串两端空白",{"2":{"137":1}}],["专门开辟的一块区域",{"2":{"135":1}}],["专为简化集合数据处理而生",{"2":{"65":1}}],["比较",{"2":{"180":1}}],["比较的是",{"2":{"134":1}}],["比如断电了",{"2":{"163":1}}],["比如数据库",{"2":{"159":1}}],["比如数据集",{"2":{"27":1}}],["比如远程方法调用",{"2":{"154":1}}],["比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作",{"2":{"146":1}}],["比如将密码用string的类型保存",{"2":{"133":1}}],["比如作为",{"2":{"133":1}}],["比如涉及到钱的场景",{"2":{"121":1}}],["比如关键词是否正确等等",{"2":{"86":1}}],["比如存储过程",{"2":{"84":1}}],["比如一个用户的信息",{"2":{"82":1}}],["比如用户表",{"2":{"82":1}}],["比如访问私有的属性和方法",{"2":{"69":1}}],["比如可以无视泛型参数的安全检查",{"2":{"69":1}}],["比如向容器中添加一个元素",{"2":{"42":1}}],["比如copyonwritearraylist类",{"2":{"39":1}}],["比如arraylist",{"2":{"38":1}}],["比如统计网站pv",{"2":{"27":1}}],["比如直播间送礼物的排行榜",{"2":{"23":1}}],["比如滴滴叫车",{"2":{"14":1}}],["比如百万级网页",{"2":{"14":1}}],["比如签到",{"2":{"14":1}}],["比如排行榜",{"2":{"14":1}}],["比如点赞",{"2":{"14":1}}],["比如",{"2":{"13":1,"19":1,"82":1,"118":1}}],["比如当我们给风景拍照时",{"2":{"10":1}}],["比如重启",{"2":{"9":1}}],["既然我们的string是不可变的",{"2":{"133":1}}],["既保证了",{"2":{"11":1}}],["假如string类不是固定不变的",{"2":{"133":1}}],["假若string不是固定不变的",{"2":{"133":1}}],["假设先写redo",{"2":{"87":1}}],["密码通常情况下都是以string类型保存",{"2":{"133":1}}],["出于安全考虑",{"2":{"133":1}}],["出来的重写子进程会先将与主线程共享的内存数据以",{"2":{"11":1}}],["单线程操作字符串缓冲区下操作大量数据",{"2":{"131":1}}],["单列集合",{"2":{"70":1}}],["范围的缓存数据",{"2":{"122":1}}],["种包装类默认创建了数值",{"2":{"122":1}}],["种锁的开销较小",{"2":{"77":1}}],["宽度是有限的",{"2":{"120":1}}],["拆箱",{"2":{"119":1}}],["拆分为",{"2":{"83":1}}],["装箱",{"2":{"119":1}}],["丰富了基本类型的操作",{"2":{"118":1}}],["完全不会对其生存时间构成影响",{"2":{"115":1}}],["完成过滤",{"2":{"65":1}}],["垃圾收集器永远不会回收掉被引用的对象",{"2":{"115":1}}],["强引用",{"2":{"115":1}}],["虚引用",{"2":{"115":2}}],["虚拟机内存不够错误",{"2":{"139":1}}],["虚拟机运行错误",{"2":{"139":1}}],["虚拟机",{"2":{"112":1,"139":1}}],["弱引用",{"2":{"115":2}}],["软引用",{"2":{"115":2}}],["普通代码块",{"2":{"114":1}}],["普通属性",{"2":{"114":1}}],["普通字符串",{"2":{"15":1}}],["他们也不一定是相等的",{"2":{"129":1}}],["他们三者的关系",{"2":{"112":1}}],["他们的区别就在于是否在",{"2":{"10":1}}],["版本管理",{"2":{"181":1}}],["版本控制",{"2":{"181":1}}],["版本的",{"2":{"112":2}}],["版新增",{"2":{"14":4}}],["针对不同的系统有不同的",{"2":{"112":1}}],["能提高读取和输入的效率",{"2":{"160":1}}],["能够跨平台运行的核心在于",{"2":{"112":1}}],["能否能够降低一定的精度来平衡存储空间",{"2":{"27":1}}],["英文名称",{"2":{"112":3}}],["编辑",{"2":{"181":1}}],["编写复杂报表",{"2":{"181":1}}],["编写",{"2":{"181":2}}],["编写小工具",{"2":{"181":1}}],["编写的程序需要先经过编译步骤",{"2":{"111":1}}],["编译器则通过调用类似intvalue",{"2":{"119":1}}],["编译器",{"2":{"112":1}}],["编译语言的执行速度比较快",{"2":{"111":1}}],["编译型语言open",{"2":{"111":1}}],["编译型",{"2":{"111":1}}],["编译与解释并存",{"0":{"111":1}}],["编译后会生成",{"2":{"110":1}}],["解释器来解释执行",{"2":{"111":1}}],["解释型语言开发效率比较快",{"2":{"111":1}}],["解释型语言open",{"2":{"111":1}}],["解释型",{"2":{"111":1}}],["解决",{"0":{"59":1}}],["解决基数问题有很多种方案",{"2":{"27":1}}],["开源项目结构",{"2":{"181":1}}],["开发基础与框架入门",{"2":{"181":1}}],["开发手册",{"2":{"181":1}}],["开发环境搭建",{"0":{"180":1}}],["开发工具包",{"2":{"112":1}}],["开发效率比较低",{"2":{"111":1}}],["开头为",{"2":{"11":1}}],["异常处理",{"2":{"180":1}}],["异常处理是java中使得程序更稳健的另一个特征",{"2":{"109":1}}],["异常",{"0":{"138":1},"1":{"139":1,"140":1,"141":1,"142":1,"143":1,"144":1},"2":{"140":1}}],["异常是某种类似于错误的异常条件出现的信号",{"2":{"109":1}}],["已经刷入磁盘的数据都会从",{"2":{"167":1}}],["已经明示了它的原理",{"2":{"42":1}}],["已提交",{"2":{"166":2}}],["已编译的java程序可以在任何带有jvm的平台上运行",{"2":{"109":1}}],["修饰的变量",{"2":{"132":1}}],["修饰的字段不会被序列化",{"2":{"108":1}}],["修改的行信息等",{"2":{"166":1}}],["修改的数据页号",{"2":{"166":1}}],["修改的表空间id",{"2":{"166":1}}],["修改方法的时候",{"2":{"147":1}}],["修改",{"2":{"38":1,"85":1}}],["规定",{"2":{"108":1}}],["法必须声明为",{"2":{"108":1}}],["除了可以声明方法和变量",{"2":{"108":1}}],["除此之外",{"2":{"13":1}}],["码",{"2":{"108":1}}],["总之",{"2":{"166":1}}],["总结一下jdk",{"2":{"112":1}}],["总结来说",{"2":{"77":1}}],["总是执行",{"2":{"108":1}}],["枚举",{"2":{"108":1,"156":1}}],["号将字符括起来来表示",{"2":{"108":1}}],["恢复程序状态等",{"2":{"108":1}}],["恢复数据的效率会比",{"2":{"10":1}}],["恢复数据时",{"2":{"10":1}}],["块或",{"2":{"142":1}}],["块里的语句都会被执行",{"2":{"142":1}}],["块",{"2":{"142":4}}],["块中遇到",{"2":{"142":1}}],["块中的代码",{"2":{"108":1}}],["块中",{"2":{"108":1}}],["块中可以捕获这些异常并",{"2":{"108":1}}],["块中可能会抛出异常",{"2":{"108":1}}],["块可以捕获特定类型的异常",{"2":{"108":1}}],["块可以有多个",{"2":{"108":1}}],["空间",{"2":{"108":1}}],["网页",{"2":{"171":1}}],["网络地址url",{"2":{"133":1}}],["网络传输等场景",{"2":{"108":1}}],["网站",{"2":{"24":1}}],["到处运行",{"2":{"109":1}}],["到",{"2":{"108":1}}],["到数组中不同的位置",{"2":{"53":1}}],["继续执行紧跟在循环或",{"2":{"108":1}}],["继承与实现",{"2":{"102":1}}],["继承是从已有的类中派生出新的类",{"2":{"100":1}}],["继承",{"0":{"100":1},"2":{"98":1,"101":1,"180":1}}],["程序",{"2":{"180":1}}],["程序未执行到try代码块",{"2":{"143":1}}],["程序本身可以处理的异常",{"2":{"139":1}}],["程序要经过先编译",{"2":{"111":1}}],["程序员可以找到出错的处理代码",{"2":{"109":1}}],["程序将立即跳出当前循环或",{"2":{"108":1}}],["程序可以绕过编译时的静态检查",{"2":{"67":1}}],["循环",{"2":{"108":1}}],["循环控制和逻辑运算等场景",{"2":{"108":1}}],["易用性和学习曲线",{"2":{"107":1}}],["跨平台能力",{"2":{"107":1}}],["改变副本不影响原变量",{"2":{"106":1}}],["传递的是该对象地址的一个副本",{"2":{"106":1}}],["传递的是该变量的一个副本",{"2":{"106":1}}],["传递到服务器解析并执行的一种攻击手法",{"2":{"91":1}}],["深拷贝把要复制的对象所引用的对象都复制了一遍",{"2":{"104":1}}],["深拷贝相比于浅拷贝速度较慢并且花销较大",{"2":{"104":1}}],["深拷贝会拷贝所有的属性",{"2":{"104":1}}],["深拷贝是一个整个独立的对象拷贝",{"2":{"104":1}}],["深拷贝",{"2":{"104":1}}],["深拷贝和浅拷贝区别了解吗",{"0":{"103":1},"1":{"104":1}}],["简化配置",{"2":{"181":2}}],["简化了内存管理",{"2":{"107":1}}],["简单部署",{"2":{"181":1}}],["简单来说",{"2":{"153":1,"169":1}}],["简单来说就是",{"2":{"146":1}}],["简单类型",{"2":{"117":1}}],["简而言之",{"2":{"104":2}}],["简称",{"2":{"19":1}}],["浅拷贝仅仅复制所考虑的对象",{"2":{"104":1}}],["浅拷贝",{"2":{"104":1}}],["静态代理在编译时就将接口",{"2":{"151":1}}],["静态代理中",{"2":{"151":1}}],["静态代理和动态代理的对比",{"0":{"151":1}}],["静态代理实现简单",{"2":{"147":1}}],["静态代理实现步骤",{"2":{"147":1}}],["静态代理优缺点",{"2":{"147":1}}],["静态代理",{"0":{"147":1},"2":{"147":1}}],["静态代码块",{"2":{"114":1}}],["静态属性",{"2":{"114":1}}],["静态成员",{"2":{"102":1}}],["静态多态性",{"2":{"101":1}}],["抽象方法必须为public或者protected",{"2":{"102":1}}],["抽奖系统",{"2":{"24":1}}],["抽奖活动等",{"2":{"14":1}}],["访问修饰符",{"2":{"102":1}}],["成员变量",{"2":{"102":1,"180":1}}],["语言既具有编译型语言的特征",{"2":{"111":1}}],["语言",{"0":{"111":1}}],["语言特性",{"2":{"107":1}}],["语法和声明方式",{"2":{"102":1}}],["语句块肯定不会执行了",{"2":{"143":1}}],["语句块时",{"2":{"143":1}}],["语句块时被打断",{"2":{"143":1}}],["语句块可能不会执行",{"2":{"143":1}}],["语句块或者",{"2":{"143":2}}],["语句块将在方法返回之前被执行",{"2":{"142":1}}],["语句中的异常",{"2":{"108":1}}],["语句后面的代码",{"2":{"108":1}}],["语句时",{"2":{"108":1,"142":1}}],["语句",{"2":{"108":2}}],["语句会报错",{"2":{"91":1}}],["语句是否有语法错误",{"2":{"86":1}}],["语句的关键元素",{"2":{"86":1}}],["语句为",{"2":{"86":1}}],["语句就会经过分析器",{"2":{"84":1}}],["运用反序列化手段",{"2":{"113":1}}],["运行流程",{"2":{"180":1}}],["运行时异常",{"0":{"140":1}}],["运行时环境",{"2":{"112":1}}],["运行java程序必须有jvm的支持",{"2":{"110":1}}],["运行我们编写的java程序",{"2":{"110":1}}],["运行期间判断所引用对象的实际类型",{"2":{"101":1}}],["运算符",{"2":{"94":1,"180":1}}],["运算才有意义",{"2":{"56":1}}],["做出不同的处理",{"2":{"101":1}}],["父类引用指向子类对象",{"2":{"101":1}}],["父子进程是共享内存数据的",{"2":{"9":1}}],["良好的封装能够减少耦合",{"2":{"99":1}}],["封装就是将类的信息隐藏在类内部",{"2":{"99":1}}],["封装",{"0":{"99":1},"2":{"98":1,"180":1}}],["封装出一个",{"2":{"59":1}}],["名字与类名相同",{"2":{"97":1}}],["构造函数",{"2":{"102":1}}],["构造方法",{"2":{"114":1,"180":1}}],["构造方法不能被",{"2":{"97":1}}],["构造方法特点如下",{"2":{"97":1}}],["构造方法有哪些特点",{"0":{"97":1}}],["构成一个有序列表",{"2":{"16":1,"18":1}}],["参数的顺序",{"2":{"96":1}}],["参数的个数",{"2":{"96":1}}],["参数列表又叫参数签名",{"2":{"96":1}}],["参数占位符",{"2":{"91":1}}],["条绳子系住一个气球",{"2":{"94":1}}],["条件为真",{"2":{"57":1}}],["条件设置",{"2":{"32":1}}],["创建",{"2":{"181":1}}],["创建一个代理类同样实现这个接口",{"2":{"147":1}}],["创建一个对象用什么运算符",{"0":{"94":1}}],["创建了数值在",{"2":{"122":1}}],["创建对象",{"2":{"113":1}}],["创建对象实例",{"2":{"94":1}}],["创建子进程",{"2":{"10":1}}],["创建子进程时",{"2":{"9":1}}],["面向过程把解决问题的过程拆成一个个方法",{"2":{"93":1}}],["面向对象编程",{"2":{"180":1}}],["面向对象性",{"2":{"107":1}}],["面向对象三大特性",{"0":{"98":1},"1":{"99":1,"100":1,"101":1},"2":{"98":1}}],["面向对象会先抽象出对象",{"2":{"93":1}}],["面向对象和面向过程是一种软件开发思想",{"2":{"93":1}}],["面向对象和面向过程的区别",{"0":{"93":1}}],["面向对象基础",{"0":{"92":1},"1":{"93":1,"94":1,"95":1,"96":1,"97":1,"98":1,"99":1,"100":1,"101":1,"102":1,"103":1,"104":1}}],["拼接替换符",{"2":{"91":1}}],["拼接起来",{"2":{"91":1}}],["$",{"2":{"91":1}}],["被弱引用关联的对象只能生存到下一次垃圾收集发生之前",{"2":{"115":1}}],["被复制对象的所有变量都含有与原来的对象相同的值",{"2":{"104":1}}],["被替换为任何参数",{"2":{"91":1}}],["被后一个",{"2":{"58":1}}],["quot",{"0":{"136":2},"2":{"91":2}}],["queue",{"2":{"70":2,"73":4}}],["尽量减少事务回滚和数据删除操作",{"2":{"90":1}}],["手动设置自增",{"2":{"90":1}}],["虽然",{"2":{"167":1}}],["虽然c++代码也可以跨平台",{"2":{"107":1}}],["虽然每个节点内部是连续的",{"2":{"90":1}}],["虽然压缩列表可以有效减少内存占用",{"2":{"16":1}}],["什么会导致mysql",{"0":{"90":1}}],["什么是",{"0":{"169":1}}],["什么是反序列化",{"0":{"153":1}}],["什么是反射",{"0":{"67":1}}],["什么是序列化",{"0":{"153":1}}],["什么是字符串常量池",{"0":{"135":1}}],["什么是自动拆装箱",{"2":{"119":1}}],["什么是值传递和引用传递",{"0":{"106":1}}],["什么是深拷贝和浅拷贝",{"0":{"104":1}}],["什么是引用拷贝",{"0":{"103":1},"1":{"104":1}}],["什么是sql注入",{"0":{"91":1}}],["什么是stream流",{"0":{"65":1}}],["什么是关系型数据库",{"0":{"82":1}}],["什么是基数",{"2":{"27":1}}],["什么是hyperloglog",{"0":{"27":1}}],["什么是跳表",{"0":{"17":1}}],["什么是redis",{"0":{"13":1}}],["决定是回滚还是执行",{"2":{"89":1}}],["全连接",{"2":{"88":1}}],["左表返回匹配行",{"2":{"88":1}}],["左连接",{"2":{"88":1}}],["右连接",{"2":{"88":1}}],["右表返回匹配行",{"2":{"88":1}}],["右⼦节点树种的任何节点",{"2":{"62":1}}],["机器挂了",{"2":{"87":1}}],["引导其生成更准确",{"2":{"169":1}}],["引用类型指向的对象的状态也不能改变",{"2":{"132":1}}],["引用类型的变量不能指向其他的对象",{"2":{"132":1}}],["引用传递一般是对于对象型变量而言的",{"2":{"106":1}}],["引用相等一般比较的是他们指向的内存地址是否相等",{"2":{"95":1}}],["引擎将数据保存在内存中",{"2":{"87":1}}],["引入了行级锁和外键约束",{"2":{"75":1}}],["引入的核心特性之一",{"2":{"65":1}}],["拿到查询结果",{"2":{"87":1}}],["拿时间戳作为score",{"2":{"29":1}}],["举个例子",{"2":{"87":1}}],["更准确的建议",{"2":{"169":1}}],["更相关的回答",{"2":{"169":1}}],["更加灵活",{"2":{"150":1}}],["更新或删除",{"2":{"166":1}}],["更新完成",{"2":{"87":1}}],["更新为张三",{"2":{"87":1}}],["更新语句是这样的",{"2":{"87":1}}],["更新语句执行流程",{"0":{"87":1}}],["更改商品数量直接修改对应的",{"2":{"22":1}}],["进阶版",{"2":{"181":1}}],["进阶基础",{"2":{"180":1}}],["进行同步",{"2":{"131":1}}],["进行日志记录",{"2":{"108":1}}],["进行处理",{"2":{"108":1}}],["进行权限校验",{"2":{"86":1}}],["进⾏转换的静态⽅法",{"2":{"71":1}}],["确认当前用户有权执行该操作",{"2":{"84":1}}],["确保回答是基于真实资料而不是凭空想象",{"2":{"169":1}}],["确保数据库表字段的原子性",{"2":{"83":1}}],["确保了setnx操作的原子性",{"2":{"32":1}}],["生成的动态代理类和目标类都实现相同的接口",{"2":{"149":1}}],["生成字节码",{"2":{"111":1}}],["生成类的对象时自动执行",{"2":{"97":1}}],["生成策略",{"2":{"90":1}}],["生成执行计划",{"2":{"84":1}}],["生产者需要自行实现全局唯一",{"2":{"14":1}}],["词法分析和语法分析",{"2":{"84":1}}],["没有实现cloneable的话会抛异常clonenotsupportedexception",{"2":{"124":1}}],["没有返回值",{"2":{"97":1}}],["没有命中缓存的话",{"2":{"84":1}}],["没有重写",{"2":{"53":1}}],["没有重复元素",{"2":{"14":1,"15":2}}],["负责监控并自动回收不再被引用的对象的内存空间",{"2":{"107":1}}],["负责与客户端建立连接",{"2":{"84":1}}],["负载因⼦时",{"2":{"57":1}}],["连接池",{"2":{"181":1}}],["连接器",{"2":{"84":1}}],["连续签到用户总数等",{"2":{"14":1}}],["函数等",{"2":{"84":1}}],["视图",{"2":{"84":1}}],["触发器",{"2":{"84":1}}],["触发重写机制后",{"2":{"9":1}}],["层分离",{"2":{"181":1}}],["层面",{"2":{"151":1}}],["层基本组件",{"2":{"84":1}}],["层",{"2":{"84":1}}],["层和存储引擎层",{"2":{"84":1}}],["依赖引入",{"2":{"181":1}}],["依赖注入",{"2":{"181":1}}],["依赖于主键的情况",{"2":{"83":1}}],["依赖于非主键列",{"2":{"83":1}}],["依然可以继续处理操作命令的",{"2":{"10":1}}],["二",{"0":{"181":1},"2":{"181":5}}],["二进制日志",{"2":{"163":1}}],["二是非主键列必须完全依赖于主键",{"2":{"83":1}}],["二值状态统计的场景",{"2":{"14":1}}],["城市",{"2":{"83":1}}],["省份",{"2":{"83":1}}],["市和具体地址",{"2":{"83":1}}],["地址",{"2":{"83":3}}],["地理空间索引",{"2":{"19":1}}],["地理位置",{"2":{"19":1}}],["地理信息",{"2":{"13":1}}],["日期等等",{"2":{"82":1}}],["日志分析",{"2":{"181":1}}],["日志序列号",{"2":{"166":1}}],["日志模块",{"2":{"84":1}}],["日志重写过程",{"2":{"11":1}}],["日志和内存快照",{"2":{"11":1}}],["日志非常多",{"2":{"10":1}}],["日志记录的是操作命令",{"2":{"10":1}}],["日志过程中",{"2":{"9":1}}],["日志文件过大就会带来性能问题",{"2":{"9":1}}],["日志是一个文件",{"2":{"9":1}}],["日志也是在主线程中执行",{"2":{"9":1}}],["日志",{"0":{"161":1},"1":{"162":1,"163":1,"164":1,"165":1,"166":1,"167":1},"2":{"9":2}}],["日志里后",{"2":{"9":1}}],["日志里",{"2":{"9":1}}],["整数",{"2":{"82":1,"126":1}}],["整个恢复的过程就会很慢",{"2":{"9":1}}],["列包含了省",{"2":{"83":1}}],["列上的值是有数据类型的",{"2":{"82":1}}],["列代表该行中的每个值",{"2":{"82":1}}],["列表",{"2":{"13":1,"14":1,"15":1}}],["大部分需要浮点数精确运算结果的业务场景",{"2":{"121":1}}],["大部分关系型数据库都支持事务的四大特性",{"2":{"82":1}}],["大大增加程序的重用性和易维护性",{"2":{"100":1}}],["大概有4步",{"2":{"86":1}}],["大小不固定",{"2":{"79":2}}],["关系模型表明了数据库中所存储的数据之间的联系",{"2":{"82":1}}],["关系型数据库中",{"2":{"82":1}}],["关系型数据库",{"2":{"82":1}}],["关键字",{"2":{"59":1,"180":1}}],["关键字进⾏同步",{"2":{"41":1}}],["关键的技术就在于写时复制技术",{"2":{"10":1}}],["得到了不够紧凑的索引结构",{"2":{"80":1}}],["频繁的移动",{"2":{"80":1}}],["频率太高",{"2":{"11":1}}],["频率太低",{"2":{"11":1}}],["符合递增插入",{"2":{"80":1}}],["自查代码规范",{"2":{"181":1}}],["自己分分支开发",{"2":{"181":1}}],["自定义异常",{"2":{"180":1}}],["自身没有方法",{"2":{"124":1}}],["自动装箱时编译器会调用包装类的valueof方法将原始类型的值转换成对象",{"2":{"119":1}}],["自动装箱与拆箱了解吗",{"0":{"119":1}}],["自动生成全局唯一消息id",{"2":{"14":1}}],["自增",{"2":{"90":1}}],["自增主键",{"0":{"90":1},"2":{"90":1}}],["自增主键的插入模式",{"2":{"80":1}}],["页中某些记录的相对位置",{"2":{"79":1}}],["页中尚未使用的部分",{"2":{"79":1}}],["真正存储我们插入的数据",{"2":{"79":1}}],["占固定大小",{"2":{"79":1}}],["占固定的26字节",{"2":{"79":1}}],["占固定的56字节",{"2":{"79":1}}],["占固定的38字节",{"2":{"79":1}}],["占用的数据空间相对较大",{"2":{"75":1}}],["占用",{"2":{"19":1}}],["占用空间很小",{"2":{"19":1}}],["占用空间非常非常小",{"2":{"19":1}}],["表结构",{"2":{"181":1}}],["表创建",{"2":{"181":1}}],["表达式",{"2":{"181":1}}],["表达式防止sql注入与preparedstatement类似",{"2":{"91":1}}],["表名",{"2":{"91":1}}],["表扫描顺序等",{"2":{"84":1}}],["表中的每一行就存放着一条数据",{"2":{"82":1}}],["表示的只是异常的申明",{"2":{"144":1}}],["表示该变量或方法是静态变量或静态方法",{"2":{"108":1}}],["表示方法或变量对同一包内的类和所有子类可见",{"2":{"108":1}}],["表示方法或变量只对当前类可见",{"2":{"108":1}}],["表示单精度浮点数",{"2":{"108":1}}],["表示无论是否处理异常",{"2":{"108":1}}],["表示布尔值",{"2":{"108":1}}],["表示数据页专有信息",{"2":{"79":1}}],["表示页的一些通用信息",{"2":{"79":1}}],["表级锁是粗粒度的锁",{"2":{"77":1}}],["表级锁",{"2":{"77":1}}],["特性",{"2":{"181":1}}],["特别是在高并发的环境中",{"2":{"78":1}}],["特有的",{"2":{"19":1}}],["间隙锁是锁定一个范围内的索引记录",{"2":{"78":1}}],["间隙锁",{"2":{"78":1}}],["记录逻辑操作",{"2":{"165":1}}],["记录内容",{"2":{"165":1}}],["记录了这个页的字段值变化",{"2":{"167":1}}],["记录了对mysql数据库执行更改的所有操作",{"2":{"165":1}}],["记录了所有更改数据或可能更改数据的sql语句",{"2":{"163":1}}],["记录物理数据页面的修改信息",{"2":{"164":1,"165":1}}],["记录数据的逻辑变化",{"2":{"164":1}}],["记录数据页的物理修改操作",{"2":{"164":1,"165":1}}],["记录事务对数据所做的修改前的状态",{"2":{"164":1}}],["记录的是数据修改之后的值",{"2":{"163":1}}],["记录的是实际数据",{"2":{"10":1}}],["记录锁是直接锁定某行记录的锁",{"2":{"78":1}}],["记录锁",{"2":{"78":1}}],["加锁速度快",{"2":{"77":1}}],["加载完",{"2":{"11":1}}],["加载数据的时候",{"2":{"11":1}}],["行异常处理",{"2":{"108":1}}],["行代表每一行数据",{"2":{"82":1}}],["行和列",{"2":{"82":1}}],["行锁的选择和配置取决于具体的应用场景和性能要求",{"2":{"78":1}}],["行锁主要有记录锁和间隙锁两种类型",{"2":{"78":1}}],["行锁有哪几种",{"0":{"78":1}}],["行锁大幅度提高了多用户并发操作的性能",{"2":{"76":1}}],["行级锁提供了更好的并发性能",{"2":{"77":1}}],["行级锁是细粒度的锁",{"2":{"77":1}}],["行级锁",{"2":{"77":1}}],["行级锁和表级锁是数据库中用于控制并发操作的两种不同类型的锁",{"2":{"77":1}}],["行级锁和表级锁",{"0":{"77":1}}],["应用场景",{"2":{"164":1,"165":1}}],["应用程序可以利用全限定名创建可扩展对象的实例",{"2":{"69":1}}],["应用程序通过同步机制去控制",{"2":{"40":1}}],["应该修正程序避免这类异常发生",{"2":{"140":1}}],["应该将",{"2":{"83":1}}],["应对高并发事务",{"2":{"76":1}}],["具有",{"0":{"167":1},"2":{"167":1}}],["具有事务",{"2":{"76":1}}],["具体地址",{"2":{"83":1}}],["具体来说",{"2":{"18":1,"166":1}}],["具体内核缓冲区的数据什么时候写入到硬盘",{"2":{"9":2}}],["备份",{"2":{"76":1}}],["备份及恢复",{"2":{"76":1}}],["栈是⼀种后进先出",{"2":{"73":1}}],["双端队列",{"2":{"73":1}}],["双向链表的插入和删除只需要改变前驱节点",{"2":{"36":1}}],["⽐较器进⾏排序",{"2":{"73":1}}],["⽐如",{"2":{"44":1}}],["第二点",{"2":{"167":1}}],["第二范式2nf",{"2":{"83":1}}],["第一个",{"2":{"180":1}}],["第一点",{"2":{"167":1}}],["第一范式1nf",{"2":{"83":1}}],["第三范式3nf",{"2":{"83":1}}],["第⼀个加⼊队列的元素会成为第⼀个被移出的元素",{"2":{"73":1}}],["第⼆次",{"2":{"44":1}}],["队列是⼀种先进先出",{"2":{"73":1}}],["队列和栈",{"0":{"73":1}}],["冲突",{"2":{"72":1}}],["打印",{"2":{"71":1}}],["⼆分查找",{"2":{"71":1}}],["包中的",{"2":{"139":1}}],["包括ddl和dml语句",{"2":{"165":1}}],["包括基本数据类型的值不能改变",{"2":{"132":1}}],["包括使用指针和手动分配及释放内存",{"2":{"107":1}}],["包括函数",{"2":{"107":1}}],["包括参数的类型",{"2":{"96":1}}],["包括选择合适的索引",{"2":{"84":1}}],["包括索引的选择和表的读取顺序",{"2":{"84":1}}],["包下",{"2":{"71":1}}],["包装类型的缓存机制了解么",{"0":{"122":1}}],["包装",{"2":{"40":1}}],["典型代表就是双端队列arraydeque",{"2":{"70":1}}],["典型代表就是",{"2":{"70":2}}],["典型代表就是封装了动态数组的",{"2":{"70":1}}],["组成",{"0":{"84":1},"2":{"70":1}}],["代理类这些都变成了一个个实际的",{"2":{"151":1}}],["代理类根据目标类实现的接口动态生成",{"2":{"149":1}}],["代理类在编译阶段生成",{"2":{"147":1}}],["代理模式的主要作用是扩展目标对象的功能",{"2":{"146":1}}],["代理模式是一种比较好理解的设计模式",{"2":{"146":1}}],["代理",{"0":{"146":1},"1":{"147":1,"148":1,"149":1,"150":1,"151":1}}],["代",{"2":{"108":1}}],["代码评审",{"2":{"181":1}}],["代码托管",{"2":{"181":1}}],["代码规范",{"2":{"181":1}}],["代码在编译过程中",{"2":{"140":1}}],["代码中声明但在本地代码",{"2":{"108":1}}],["代码的行为就有可能也随着变化",{"2":{"69":1}}],["代表键值对的集合",{"2":{"70":1}}],["代表队列",{"2":{"70":1}}],["代表无序",{"2":{"70":1}}],["代表有序",{"2":{"70":1}}],["代替",{"2":{"40":2}}],["无法替代的",{"0":{"167":1}}],["无法对这些代码进行优化",{"2":{"69":1}}],["无限循环的小数存储在计算机时",{"2":{"120":1}}],["无需调用",{"2":{"97":1}}],["无论是否捕获或处理异常",{"2":{"142":1}}],["无论当前内存是否足够",{"2":{"115":1}}],["无论",{"2":{"91":1}}],["无序集合",{"2":{"14":1,"15":1}}],["定义一个接口及其实现类",{"2":{"147":1}}],["定义",{"2":{"69":1}}],["测试工具可以利用反射来自动地调用类里定义的可被发现的",{"2":{"69":1}}],["调试技巧",{"2":{"181":2}}],["调试与排查",{"2":{"181":1}}],["调试器",{"2":{"112":1}}],["调试器需要能够检查一个类里的私有成员",{"2":{"69":1}}],["调试器和测试工具",{"2":{"69":1}}],["调用者",{"2":{"144":1}}],["调用clone方法时",{"2":{"124":1}}],["调用java",{"2":{"113":1}}],["调用对象的clone",{"2":{"113":1}}],["调用zadd来生产消息",{"2":{"29":1}}],["另外非主键列必须直接依赖于主键",{"2":{"83":1}}],["另外包含两部分内容",{"2":{"83":1}}],["另外",{"2":{"69":1,"112":1,"151":1}}],["究竟是怎么起作用的呢",{"2":{"68":1}}],["呢",{"2":{"68":1}}],["注册",{"2":{"181":1}}],["注解配置",{"2":{"181":1}}],["注解",{"2":{"68":1}}],["注意这里说叶子节点其实是图中的",{"2":{"49":1}}],["注意",{"2":{"38":1}}],["像",{"2":{"68":1}}],["你可以在windows平台编写代码",{"2":{"109":1}}],["你可以将",{"2":{"19":1,"26":1}}],["你仍然可以有全局函数和全局变量",{"2":{"107":1}}],["你获取到注解之后",{"2":{"68":1}}],["你才能这么轻松地使用各种框架",{"2":{"68":1}}],["正是因为反射",{"2":{"68":1}}],["正好相当于⼀个",{"2":{"56":1}}],["动态创建目标类的子类对象",{"2":{"150":1}}],["动态代理是在运行时动态生成类字节码",{"2":{"148":1}}],["动态代理机制",{"2":{"148":1}}],["动态代理更加灵活",{"2":{"148":1,"151":1}}],["动态代理",{"0":{"148":1},"1":{"149":1,"150":1,"151":1}}],["动态代理等场景",{"2":{"67":1}}],["动态多态性",{"2":{"101":1}}],["动态点赞等等",{"2":{"24":1}}],["用",{"2":{"181":3}}],["用特定的语气和用户交流",{"2":{"169":1}}],["用来描述非必需对象",{"2":{"115":1}}],["用来描述一些还有用但并非必需的对象",{"2":{"115":1}}],["用new语句创建对象",{"2":{"113":1}}],["用于记录数据库中每个事务的修改操作",{"2":{"166":1}}],["用于数据恢复",{"2":{"165":1}}],["用于事务回滚时恢复数据到原始状态",{"2":{"164":1}}],["用于事务回滚和mvcc",{"2":{"164":1}}],["用于处理",{"2":{"142":1}}],["用于指定方法没有返回值",{"2":{"108":1}}],["用于指定多线程代码中的同步方法",{"2":{"108":1}}],["用于限制浮点数计算的精度",{"2":{"108":1}}],["用于判断对象是否属于某个类型",{"2":{"108":1}}],["用于实现接口",{"2":{"108":1}}],["用于表示长整数值",{"2":{"108":1}}],["用于表示某个变量",{"2":{"108":1}}],["用于表示一个",{"2":{"108":1}}],["用于定义一组固定的常量",{"2":{"108":1}}],["用于声明异常",{"2":{"108":1}}],["用于声明一个本地方法",{"2":{"108":1}}],["用于声明一个双精度浮点类型的变量",{"2":{"108":1}}],["用于声明一个字符类型的变量",{"2":{"108":1}}],["用于声明抽象类",{"2":{"108":1}}],["用于捕获异常",{"2":{"142":1}}],["用于捕获",{"2":{"108":1}}],["用于跳出循环结构",{"2":{"108":1}}],["用于检验页是否完整",{"2":{"79":1}}],["用法",{"2":{"65":1}}],["用户管理",{"2":{"181":1}}],["用户系统",{"2":{"181":1}}],["用户表",{"2":{"181":1}}],["用户登录注册",{"2":{"181":1}}],["用户在操作myisam表时",{"2":{"76":1}}],["用户添加商品就是往",{"2":{"22":1}}],["用户",{"2":{"22":1}}],["高频数据缓存",{"2":{"181":1}}],["高性能",{"2":{"181":1}}],["高效",{"2":{"65":1}}],["高些",{"2":{"10":1}}],["聚合等操作",{"2":{"65":1}}],["聚合计算",{"2":{"14":1}}],["映射文件",{"2":{"181":1}}],["映射",{"2":{"65":1,"181":1}}],["映射到桶数组对应索引的位置",{"2":{"48":1}}],["或",{"2":{"108":2,"136":1}}],["或假",{"2":{"108":1}}],["或数组等数据源抽象为",{"2":{"65":1}}],["或者在网络传输",{"2":{"153":1}}],["或者被终止",{"2":{"143":1}}],["或者用mysqldump",{"2":{"76":1}}],["或者",{"2":{"60":1}}],["或者做运算皆可",{"2":{"22":1}}],["如用户登录流程",{"2":{"181":1}}],["如统计",{"2":{"181":1}}],["如递归字符",{"2":{"171":1}}],["如段落",{"2":{"171":1}}],["如服务器宕机或者数据库进程异常退出",{"2":{"166":1}}],["如sql语句及其增删改操作的反向信息",{"2":{"165":1}}],["如数据页的变更",{"2":{"164":1}}],["如insert操作会记录相反的delete操作信息",{"2":{"164":1}}],["如不⽤泛型",{"2":{"145":1}}],["如何使用",{"0":{"142":1}}],["如何检查重复",{"2":{"127":1}}],["如何解决浮点数运算的精度丢失问题",{"0":{"121":1}}],["如何解决sql注入",{"2":{"91":1}}],["如jinfo",{"2":{"112":1}}],["如编译器和调试器等",{"2":{"112":1}}],["如文件读写",{"2":{"108":1}}],["如内存泄露和空悬指针等问题",{"2":{"107":1}}],["如雪花算法",{"2":{"90":1}}],["如有错误",{"2":{"84":1}}],["如共享锁",{"2":{"78":1}}],["如大于",{"2":{"78":1}}],["如等号=",{"2":{"78":1}}],["如能够自动在内存中创建自适应hash索引",{"2":{"75":1}}],["如",{"2":{"65":1,"69":2,"91":1,"108":1,"154":1,"155":1,"171":1,"181":1}}],["如果写入失败",{"2":{"167":1}}],["如果事务执行了一条insert语句",{"2":{"163":1}}],["如果用transient声明一个实例变量",{"2":{"155":1}}],["如果目标类没有实现接口",{"2":{"150":1}}],["如果目标类实现了接口",{"2":{"149":1}}],["如果某个类没有实现接口",{"2":{"149":1}}],["如果某些原因导致插入失败",{"2":{"90":1}}],["如果子类没有覆盖该方法",{"2":{"141":1}}],["如果字符串常量池中不存在字符串对象",{"2":{"136":1}}],["如果该字符串已经存在池中",{"2":{"135":1}}],["如果重写",{"2":{"128":1}}],["如果两者相同",{"2":{"127":1}}],["如果我们想要得到一个对象的副本",{"2":{"124":1}}],["如果超出对应范围仍然会去创建新的对象",{"2":{"122":1}}],["如果这次回收还没有足够的内存才会抛出内存溢出异常",{"2":{"115":1}}],["如果你只是想运行java程序",{"2":{"112":1}}],["如果在插入数据时手动设置了自增",{"2":{"90":1}}],["如果检查没问题就执行下一步",{"2":{"86":1}}],["如果有些字段不想进行序列化怎么办",{"0":{"155":1}}],["如果有直接返回缓存结果",{"2":{"86":1}}],["如果有权限就会调用数据库引擎接口",{"2":{"86":1}}],["如果有权限",{"2":{"86":1}}],["如果有缓存这个",{"2":{"84":1}}],["如果没有相符的",{"2":{"127":1}}],["如果没有",{"2":{"86":1,"142":1}}],["如果没有权限就会返回错误信息",{"2":{"86":1}}],["如果没有权限",{"2":{"86":1}}],["如果没有命中",{"2":{"84":1}}],["如果没有指定⽐较器",{"2":{"62":1}}],["如果学号和课程编号组成联合主键",{"2":{"83":1}}],["如果一个对象既不是字符串",{"2":{"156":1}}],["如果一个对象",{"2":{"132":1}}],["如果一个表中包含学生信息和院校信息",{"2":{"83":1}}],["如果一个表中的",{"2":{"83":1}}],["如果一个程序必须在有安全限制的环境中运行",{"2":{"69":1}}],["如果加锁以后的表满足insert并发的情况下",{"2":{"76":1}}],["如果不存在",{"2":{"135":1}}],["如果不相同",{"2":{"129":1}}],["如果不同的话",{"2":{"127":1}}],["如果不为空",{"2":{"63":1}}],["如果不想sleep的话",{"2":{"28":1}}],["如果为空",{"2":{"63":1}}],["如果发生错误导致事务回滚",{"2":{"90":1}}],["如果发生冲突",{"2":{"48":1}}],["如果发⽣哈希冲突",{"2":{"63":1}}],["如果想使用有序的map",{"2":{"60":1}}],["如果想要使用",{"2":{"25":1,"26":1}}],["如果计算出来的索引位置是相同的",{"2":{"58":1}}],["如果",{"2":{"57":1,"89":1,"167":1}}],["如果只重写",{"2":{"53":1}}],["如果链表⻓度",{"2":{"63":1}}],["如果链表中插入节点的时候",{"2":{"52":1}}],["如果链表长度",{"2":{"48":1}}],["如果对应小标正好没有存放数据",{"2":{"52":1}}],["如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息",{"2":{"21":1}}],["如果是则进行扩容操作",{"2":{"52":1}}],["如果是在链表的尾部插⼊或者删除",{"2":{"36":1}}],["如果是在链表的中间插⼊或者删除",{"2":{"36":1}}],["如果是在链表的头部插⼊或者删除",{"2":{"36":1}}],["如果红黑树节点个数",{"2":{"48":1}}],["如果集合发生变化时修改modcount值刚好又设置为了expectedmodcount值",{"2":{"38":1}}],["如果线程a遍历过程中",{"2":{"38":1}}],["如果数组满了",{"2":{"37":1}}],["如果数值是5",{"2":{"20":1}}],["如果key不存在",{"2":{"32":1}}],["如果key已经存在",{"2":{"32":1}}],["如果系统对性能和资源消耗非常敏感的话",{"2":{"21":1}}],["如果ziplist编码所需的两个条件中的任意一个不再满足时",{"2":{"18":1}}],["如果小于要查找的值",{"2":{"17":1}}],["如果开启混合持久化",{"2":{"11":1}}],["如果主线程执行写操作",{"2":{"10":1}}],["如果主进程修改了已经存在",{"2":{"9":1}}],["如果频率太低",{"2":{"10":1}}],["如果频率太频繁",{"2":{"10":1}}],["如果文件过大",{"2":{"9":1}}],["如果当一个线程在执行",{"2":{"143":1}}],["如果当日活跃过就设置为",{"2":{"26":1}}],["如果当前桶是链表",{"2":{"57":1}}],["如果当前桶是红⿊树",{"2":{"57":1}}],["如果当前桶中只有⼀个元素",{"2":{"57":1}}],["如果当前容量+1超过数组长度",{"2":{"37":1}}],["如果当前节点的值大于要查找的值",{"2":{"17":1}}],["如果当前的命令语法有问题",{"2":{"9":1}}],["如果当",{"2":{"9":1}}],["②",{"2":{"63":1,"70":1}}],["⼤于",{"2":{"63":1}}],["①",{"2":{"63":1,"70":1}}],["逐步向左⼦树或者右⼦树递归查找",{"2":{"62":1}}],["逐一把内存数据的键值对转换成一条命令",{"2":{"9":1}}],["利⽤⼆叉查找树的特点",{"2":{"62":1}}],["⼩于其",{"2":{"62":1}}],["红⿊树是⼀种⾃平衡的⼆叉查找树",{"2":{"62":1}}],["红黑树是一种平衡的二叉树",{"2":{"51":1}}],["红黑树是为了提高查询的效率",{"2":{"48":1}}],["红黑树如何保证平衡",{"0":{"50":1}}],["红黑树本质上是一种二叉查找树",{"2":{"49":1}}],["红黑树",{"0":{"49":1}}],["接收到序列化的对象之后需要再进行反序列化",{"2":{"154":1}}],["接下来就是优化器进行确定执行方案",{"2":{"86":1}}],["接⼝的⼦类",{"2":{"73":1}}],["接⼝和并发包下的",{"2":{"73":1}}],["接⼝",{"2":{"62":1,"73":2}}],["接口文档生成",{"2":{"181":1}}],["接口一旦新增加方法",{"2":{"151":1}}],["接口或方法上使用",{"2":{"108":1}}],["接口中可以定义默认方法和静态方法",{"2":{"102":1}}],["接口中的方法默认为public",{"2":{"102":1}}],["接口中的方法默认都是公共的抽象方法",{"2":{"102":1}}],["接口没有构造函数",{"2":{"102":1}}],["接口只能定义公共静态最终字段",{"2":{"102":1}}],["接口使用interface关键字进行声明",{"2":{"102":1}}],["接口和抽象类有什么共同点和区别",{"0":{"102":1}}],["接口",{"0":{"156":1},"2":{"36":2,"181":1}}],["标签",{"2":{"181":1}}],["标准化文本格式",{"2":{"171":1}}],["标准的",{"2":{"108":1}}],["标识前置节点和后置节点",{"2":{"61":1}}],["标记不支持随机访问",{"2":{"36":1}}],["标记为1",{"2":{"20":1}}],["标记数值",{"2":{"20":1}}],["粒度比较大",{"2":{"59":1}}],["锁住整个table数组",{"2":{"59":1}}],["操作少量的数据",{"2":{"131":1}}],["操作",{"2":{"58":1}}],["操作的结果就是将哈希值的⾼位全部归零",{"2":{"56":1}}],["形成死循环",{"2":{"58":1}}],["旧数组⼤⼩的位置",{"2":{"57":1}}],["+",{"2":{"57":1,"112":4,"180":1,"181":6}}],["默认比较地址值等价于==",{"2":{"125":1}}],["默认比较两个引用变量是否指向同一个对象",{"2":{"124":1}}],["默认的实现hashcode值是根据内存地址换算出来",{"2":{"124":1}}],["默认输出对象地址",{"2":{"124":1}}],["默认为public",{"2":{"102":1}}],["默认为行级锁",{"2":{"76":1}}],["默认负载因子是0",{"2":{"57":1}}],["默认会提供以下配置",{"2":{"10":1}}],["换句话说",{"2":{"56":1}}],["取决于",{"2":{"56":1}}],["奇数的⼆进制最后⼀位是",{"2":{"56":1}}],["偶数",{"2":{"56":1}}],["幂次⽅刚好是偶数",{"2":{"56":1}}],["掩码的低位最好全是",{"2":{"56":1}}],["低位掩码",{"2":{"56":1}}],[">>>",{"2":{"55":1}}],["⽆法获取到正确的值",{"2":{"53":1}}],["导致的异常",{"2":{"140":1}}],["导致出现安全隐患",{"2":{"133":1}}],["导致会执行一些预期之外的操作",{"2":{"91":1}}],["导致自增",{"2":{"90":1}}],["导致不连续",{"2":{"90":2}}],["导致",{"2":{"53":1}}],["导致占用空间越来越大",{"2":{"27":1}}],["两者指向同一片内存空间",{"2":{"106":1}}],["两者都不能直接实例化",{"2":{"102":1}}],["两者的主要区别在于解决问题的方式不同",{"2":{"93":1}}],["两个对象有相同的",{"2":{"129":1}}],["两个对象的hashcode",{"0":{"129":1}}],["两个对象会被",{"2":{"53":1}}],["两个虚拟的伪记录",{"2":{"79":1}}],["两个接⼝来实现",{"2":{"73":1}}],["两种集合都需要遍历",{"2":{"36":1}}],["超过则扩容",{"2":{"52":1}}],["否则可能退化为其他类型的锁",{"2":{"78":1}}],["否则元素移动到原索引",{"2":{"57":1}}],["否则结果⼀定是",{"2":{"56":1}}],["否则",{"2":{"54":2}}],["否则向链表中插入数据",{"2":{"52":1}}],["否则抛出异常",{"2":{"38":1}}],["^",{"2":{"52":1,"55":1}}],["覆盖clone",{"2":{"124":1}}],["覆盖",{"2":{"58":1}}],["覆盖节点",{"2":{"52":1}}],["覆盖现有的",{"2":{"9":1}}],["处理哈希冲突",{"2":{"52":1}}],["→",{"2":{"52":3}}],["平衡二叉树是比红黑树更严格的平衡树",{"2":{"51":1}}],["平衡树",{"0":{"51":1}}],["避免锁竞争",{"2":{"164":1}}],["避免了二叉树最坏情况下的o",{"2":{"51":1}}],["避免额外的检查开销",{"2":{"9":1}}],["旋转和染色",{"2":{"50":1}}],["根节点永远是黑色的",{"2":{"49":1}}],["根据其实际类型调用相应的方法",{"2":{"101":1}}],["根据优化后的执行计划调用存储引擎的api来实际执行sql语句",{"2":{"84":1}}],["根据",{"2":{"60":1}}],["根据哈希值计算下标",{"2":{"52":1}}],["根据数值范围创建一个足够大的bitmap",{"2":{"20":1}}],["根据分数升序排序",{"2":{"14":1,"15":1}}],["要么是黑色",{"2":{"49":1}}],["转为链表",{"2":{"48":1}}],["转交给操作系统控制写回的时机",{"2":{"9":1}}],["64bit",{"2":{"117":2}}],["6",{"2":{"48":1,"118":1,"181":1}}],["60",{"2":{"10":1}}],["group",{"2":{"181":1}}],["gram",{"2":{"171":1}}],["gitee",{"2":{"181":1}}],["github",{"2":{"181":2}}],["git",{"2":{"181":6}}],["guides",{"2":{"181":2}}],["go",{"2":{"111":1}}],["gc",{"2":{"107":1}}],["gap",{"2":{"78":1}}],["gt",{"2":{"48":2,"52":3,"78":1}}],["generation",{"2":{"150":1,"169":1}}],["getting",{"2":{"181":2}}],["getter",{"2":{"180":1}}],["getlocalizedmessage",{"2":{"141":1}}],["getmessage",{"2":{"141":2}}],["getbytes",{"2":{"137":1}}],["getclass",{"2":{"124":1}}],["get",{"2":{"31":1,"36":3,"53":1,"58":3}}],["geospatial",{"2":{"19":2}}],["geo",{"2":{"13":1,"14":1,"19":2}}],["链表长度大于等于8",{"2":{"52":1}}],["链表还是红⿊树",{"2":{"52":1}}],["链表转为红黑树",{"2":{"48":1}}],["链表是用来解决冲突",{"2":{"48":1}}],["链表中的节点数就越少",{"2":{"16":1}}],["桶数组是用来存储数据元素",{"2":{"48":1}}],["判断哪些数据已经刷盘",{"2":{"167":2}}],["判断是否超过阈值",{"2":{"52":1}}],["判断是否需要扩容",{"2":{"52":1}}],["判断tab",{"2":{"52":1}}],["判断tab是否位空或者长度为0",{"2":{"52":1}}],["判断元素重复的逻辑底层依然是",{"2":{"46":1}}],["判断用户登陆状态",{"2":{"14":1}}],["⽅法分裂树节点",{"2":{"57":1}}],["⽅法",{"2":{"53":2}}],["⽅法没重写",{"0":{"53":1}}],["⽅法实现的",{"2":{"46":1}}],["⽅法是通过调⽤",{"2":{"46":1}}],["⽅法来确定元素的唯⼀性",{"2":{"45":1}}],["于哈希算法",{"2":{"45":1}}],["于是",{"2":{"44":1}}],["于是父子进程就有了独立的数据副本",{"2":{"9":1}}],["⼀个相同键的元素会直接覆盖掉第⼀次的键",{"2":{"44":1}}],["结束之后再将原容器的引用指向新容器",{"2":{"42":1}}],["至于写操作",{"2":{"42":1}}],["读写文件",{"2":{"180":1}}],["读取的文件不存在或文件为空或sql异常",{"2":{"140":1}}],["读取当前数据库中的所有键值对",{"2":{"9":1}}],["读操作是无锁的",{"2":{"42":1}}],["⽤了",{"2":{"41":1}}],["⽤于替代",{"2":{"41":1}}],["jsp",{"2":{"181":1}}],["jsexport",{"2":{"174":1}}],["jstack等",{"2":{"112":1}}],["jps",{"2":{"112":1}}],["jre是java的运行环境",{"2":{"112":1}}],["jre",{"0":{"112":1},"2":{"112":5}}],["join的区别",{"0":{"88":1}}],["join和right",{"0":{"88":1}}],["join",{"0":{"88":1},"2":{"88":5,"181":1}}],["jvm首先会检查字符串常量池",{"2":{"135":1}}],["jvm三者的关系",{"0":{"112":1}}],["jvm可以理解成一个软件",{"2":{"110":1}}],["jvm",{"2":{"69":1,"107":1,"112":8,"135":1,"139":1,"148":2,"151":2}}],["jdk动态代理的核心是invocationhandler接口和proxy类",{"2":{"149":1}}],["jdk动态代理",{"0":{"149":1}}],["jdk中还有一些好用的工具",{"2":{"112":1}}],["jdk目录下有个jre",{"2":{"112":1}}],["jdk1",{"2":{"48":1,"58":2}}],["jdk",{"0":{"112":1},"2":{"41":1,"58":4,"102":1,"112":2,"180":1}}],["javase",{"2":{"181":1}}],["javascript",{"2":{"111":1}}],["java语言的关键字",{"2":{"155":1}}],["java泛型是jdk",{"2":{"145":1}}],["java赋值是复制对象引用",{"2":{"124":1}}],["java包装类型有8种",{"2":{"118":1}}],["java数据类型",{"0":{"116":1},"1":{"117":1,"118":1,"119":1,"120":1,"121":1,"122":1}}],["java对引用的概念进行了扩充",{"2":{"115":1}}],["java创建对象有以下几种方式",{"2":{"113":1}}],["java创建对象有几种方式",{"0":{"113":1}}],["java工具",{"2":{"112":1}}],["java虚拟机就是负责将字节码文件翻译成特定平台下的机器码",{"2":{"110":1}}],["java虚拟机",{"2":{"110":1}}],["java是通过jvm",{"2":{"110":1}}],["java是如何实现跨平台的",{"0":{"110":1}}],["java是一个强类型语言",{"2":{"109":1}}],["java是一门面向对象的编程语言",{"2":{"109":1}}],["java是一种纯粹的面向对象编程语言",{"2":{"107":1}}],["java要求显式的方法声明",{"2":{"109":1}}],["java具有稳健性",{"2":{"109":1}}],["java具有平台独立性和移植性",{"2":{"109":1}}],["java有一句口号",{"2":{"109":1}}],["java的基本数据类型有哪些",{"0":{"117":1}}],["java的4种引用类型",{"0":{"115":1}}],["java的特点",{"0":{"109":1}}],["java的一个主要优点是其跨平台能力",{"2":{"107":1}}],["java关键字和保留字",{"0":{"108":1}}],["java代码在任何安装了java虚拟机",{"2":{"107":1}}],["java自动进行垃圾回收",{"2":{"107":1}}],["java中的finally一定会被执行吗",{"0":{"143":1}}],["java中的所有代码",{"2":{"107":1}}],["java中类实例化顺序",{"2":{"114":1}}],["java中不存在引用传递",{"2":{"106":1}}],["java基础知识",{"0":{"105":1},"1":{"106":1,"107":1,"108":1,"109":1,"110":1,"111":1,"112":1,"113":1,"114":1,"115":1}}],["java",{"0":{"111":1,"159":1,"177":1,"178":1},"1":{"178":1,"179":2,"180":2,"181":1},"2":{"24":1,"38":1,"39":1,"55":1,"59":1,"65":2,"67":1,"68":1,"70":1,"71":1,"73":1,"108":2,"111":4,"112":8,"118":1,"139":4,"140":1,"153":3,"159":2,"180":2,"181":7}}],["时没有重写",{"2":{"128":1}}],["时一定要重写",{"0":{"128":1}}],["时引⼊的",{"2":{"41":1}}],["时",{"2":{"40":1,"58":1,"84":1,"108":1,"127":1}}],["时间复杂度",{"2":{"51":1}}],["时间复杂度是",{"2":{"36":3}}],["时间复杂度是o",{"2":{"36":2}}],["时间复杂度都是o",{"2":{"36":1}}],["时间复杂度为o",{"2":{"17":1}}],["线程安全初步认知",{"2":{"180":1}}],["线程安全",{"2":{"131":1,"133":1}}],["线程安全的方法",{"0":{"40":1}}],["线程不安全的问题",{"0":{"59":1}}],["线程",{"2":{"58":2}}],["线程b对集合对象的内容进行了修改",{"2":{"38":1}}],["缺点是访问元素时需要遍历链表",{"2":{"72":1}}],["缺点是插⼊和删除元素可能需要移动或者复制元素",{"2":{"72":1}}],["缺点",{"2":{"39":1,"75":1,"147":1,"149":1,"150":1}}],["迭代器遍历的是开始遍历那一刻拿到的集合拷贝",{"2":{"39":1}}],["迭代器并不能访问到修改后的内容",{"2":{"39":1}}],["迭代器在遍历时直接访问集合中的内容",{"2":{"38":1}}],["迭代过程中被修改",{"2":{"38":1}}],["终止遍历",{"2":{"38":1}}],["遍历链表查找",{"2":{"54":1}}],["遍历下一个元素之前",{"2":{"38":1}}],["遍历待排序的数值列表",{"2":{"20":1}}],["变量的值被设为初始值",{"2":{"155":1}}],["变量修饰符",{"2":{"155":1}}],["变量或者代码块",{"2":{"108":1}}],["变量b指向对象的这种情况",{"2":{"106":1}}],["变量",{"2":{"38":1,"107":1,"180":1}}],["变成",{"2":{"36":1}}],["原理方面",{"2":{"119":1}}],["原理是什么",{"0":{"119":1}}],["原理",{"2":{"38":1,"39":1}}],["原子性操作",{"2":{"33":1}}],["原子性",{"2":{"32":1}}],["支持加减乘除",{"2":{"181":1}}],["支持高效的相似性搜索",{"2":{"172":1}}],["支持mvcc以提供一致性读视图",{"2":{"164":1}}],["支持hash映射和缓存",{"2":{"133":1}}],["支持行级锁和表级锁",{"2":{"76":1}}],["支持事务和崩溃修复能力",{"2":{"75":1}}],["支持事务",{"2":{"75":1}}],["支持通过声明式语法",{"2":{"65":1}}],["支持随机访问",{"2":{"36":1}}],["支持以消费组形式消费数据",{"2":{"14":1}}],["素",{"2":{"36":1}}],["插⼊或者删除元素时通过旋转和染⾊来保持树的平衡",{"2":{"62":1}}],["插⼊",{"2":{"52":1}}],["插⼊和删除只需要改变前置节点",{"2":{"36":1}}],["插入数据失败",{"2":{"90":1}}],["插入",{"2":{"51":1,"166":1}}],["插入冲突的元素",{"2":{"48":1}}],["插入和删除操作",{"2":{"17":1,"18":1}}],["很多地方都需要使用对象而不是基本数据类型",{"2":{"118":1}}],["很多",{"2":{"36":1}}],["效率就会低",{"2":{"36":1}}],["甚⾄还有可能触发扩容",{"2":{"36":1}}],["甚至还有可能触发扩容",{"2":{"36":1}}],["返回的结果相同",{"2":{"141":1}}],["返回异常对象的本地化信息",{"2":{"141":1}}],["返回异常发生时的详细信息",{"2":{"141":1}}],["返回异常发生时的简要描述",{"2":{"141":1}}],["返回字符串长度",{"2":{"137":1}}],["返回字符串的",{"2":{"137":1}}],["返回一个分割后的字符串数组",{"2":{"137":1}}],["返回指定索引处的字符",{"2":{"137":1}}],["返回指定字符的索引",{"2":{"137":1}}],["返回此",{"2":{"124":1}}],["返回右表所有的行",{"2":{"88":1}}],["返回左表所有的行",{"2":{"88":1}}],["返回引擎的执行结果",{"2":{"86":1}}],["返回",{"2":{"34":1}}],["返回输入的各个元素",{"2":{"27":1}}],["通常情况下",{"2":{"121":1}}],["通常用于修饰一个方法",{"2":{"108":1}}],["通常是",{"2":{"108":1}}],["通常认为java比c++更容易学习和使用",{"2":{"107":1}}],["通常在执行更新操作时使用",{"2":{"78":1}}],["通用命令",{"0":{"34":1}}],["通过日志排查异常",{"2":{"181":1}}],["通过继承实现",{"2":{"150":1}}],["通过静态代理",{"2":{"147":1}}],["通过jvm翻译成机器码之后才能运行",{"2":{"110":1}}],["通过重载实现",{"2":{"101":1}}],["通过一个个方法的执行解决问题",{"2":{"93":1}}],["通过分析器进行词法分析",{"2":{"86":1}}],["通过反射",{"2":{"67":1}}],["通过传入",{"2":{"59":1}}],["通过",{"2":{"19":1,"26":1,"61":1,"62":1,"169":1,"181":1}}],["通过建立多层索引来实现快速查找",{"2":{"17":1}}],["通过多级索引的方式实现高效的查找",{"2":{"17":1}}],["通过多级索引提升查找效率",{"2":{"16":1}}],["通过紧凑的存储可以有效地利用空间",{"2":{"16":1,"18":1}}],["秒",{"2":{"31":1}}],["秒之内",{"2":{"10":3}}],["怎么解释呢",{"2":{"133":1}}],["怎么解决",{"0":{"91":1}}],["怎么实现有序的",{"0":{"61":1,"62":1}}],["怎么实现延时队列",{"0":{"29":1}}],["怎么判断元素重复",{"0":{"46":1}}],["怎么做",{"0":{"27":1}}],["直到垃圾收集器把它清除",{"2":{"133":1}}],["直到找到⽬标元素",{"2":{"62":1}}],["直到信息的到来",{"2":{"28":1}}],["直接把",{"2":{"167":1}}],["直接恢复数据",{"2":{"89":1}}],["直接与类的元数据交互",{"2":{"67":1}}],["直接插⼊到根节点",{"2":{"63":1}}],["直接插入或者删除就可以了",{"2":{"36":1}}],["直接返回错误信息",{"2":{"86":1}}],["直接返回",{"2":{"54":1,"122":1}}],["直接使用下面这几个命令就可以了",{"2":{"25":1}}],["直接",{"2":{"22":1}}],["添加",{"2":{"181":1}}],["添加到",{"2":{"27":1}}],["添加一个或多个元素到",{"2":{"27":1}}],["获取节点",{"2":{"54":1}}],["获取新的哈希值",{"2":{"54":1}}],["获取一个新的哈希值",{"2":{"52":1}}],["获取一个或者多个",{"2":{"27":1}}],["获取指定key的值",{"2":{"31":1}}],["获取指定位置附近的元素等功能",{"2":{"19":1}}],["快速上手",{"2":{"181":1}}],["快速失败是java集合的一种错误检测机制",{"2":{"38":1}}],["快速失败",{"2":{"38":1}}],["快速失败fail",{"0":{"38":1}}],["快速计算基数",{"2":{"27":1}}],["快照文件",{"2":{"10":1}}],["快照就是记录某一个瞬间的内存数据",{"2":{"10":1}}],["快照",{"2":{"10":1}}],["7中使用分段锁",{"2":{"59":1}}],["754",{"2":{"108":1}}],["75",{"2":{"57":1}}],["7的数据结构是数组+链表",{"2":{"48":1}}],["7",{"2":{"27":3,"58":3,"108":1,"118":1}}],["元素在数组中的存放下标",{"2":{"63":1}}],["元素的时候会先判断根节点是否为空",{"2":{"63":1}}],["元素的时候会先计算",{"2":{"63":1}}],["元素的存储顺序依赖",{"2":{"45":1}}],["元素保留在原索引的位置",{"2":{"57":1}}],["元素越多耗费内存就越多的集合形成鲜明对比",{"2":{"27":1}}],["元素不能重复",{"2":{"14":1}}],["kafka",{"2":{"181":1}}],["killed",{"2":{"143":1}}],["kit",{"2":{"112":1}}],["kb",{"2":{"27":1}}],["key的hashcode和key的hashcode右移16位做异或运算",{"2":{"55":1}}],["keys",{"2":{"34":1}}],["key2",{"2":{"27":1}}],["key1",{"2":{"27":1}}],["key",{"2":{"9":2,"22":2,"25":3,"26":2,"27":1,"31":7,"34":8,"52":2,"55":4,"58":2,"62":2,"63":2,"86":1}}],["键值存储",{"2":{"33":1}}],["键只需要花费",{"2":{"27":1}}],["键和值的字符串长度都小于64字节",{"2":{"18":1}}],["计算数组下标",{"2":{"54":1}}],["计算基数所需的空间总是固定的",{"2":{"27":1}}],["计数达到某个阈值的时候",{"2":{"19":1}}],["计数较少的时候",{"2":{"19":1}}],["计数等",{"2":{"14":1}}],["搜索记录数等需要去重和计数的问题如何解决",{"2":{"27":1}}],["搜索范围就缩小一半",{"2":{"17":1}}],["独立ip数",{"2":{"27":1}}],["独立访客",{"2":{"27":1}}],["作为主键",{"0":{"80":1},"2":{"90":1}}],["作为主要的⾮同步动态数组实现",{"2":{"41":1}}],["作为",{"2":{"26":1}}],["作者",{"0":{"0":1},"1":{"1":1}}],["精确到天",{"2":{"26":1}}],["个综合项目",{"2":{"181":1}}],["个核心步骤",{"2":{"170":1}}],["个抽象类基类中派生出来的",{"2":{"159":1}}],["个字符串对象",{"2":{"136":2}}],["个引用指向它",{"2":{"94":1}}],["个对象",{"2":{"94":1}}],["个或",{"2":{"94":1}}],["个不同元素的基数",{"2":{"27":1}}],["个",{"2":{"26":1,"171":1}}],["适用",{"2":{"131":3}}],["适用场景",{"2":{"75":1}}],["适用于数据量大且需要高并发访问的场景",{"2":{"77":1}}],["适用于框架开发",{"2":{"67":1}}],["适用于处理大量数据的排序问题",{"2":{"20":1}}],["适⽤于查找操作⽐较频繁的场景",{"2":{"63":1}}],["适合频繁的插⼊和删除操作",{"2":{"72":1}}],["适合允许重复中奖的场景",{"2":{"25":1}}],["适合不允许重复中奖的场景",{"2":{"25":1}}],["向量存储",{"2":{"172":1}}],["向量转换",{"2":{"172":1}}],["向量转换和存储",{"0":{"172":1},"2":{"170":1}}],["向指定集合添加一个或多个元素",{"2":{"25":1}}],["向跳表中插入新元素时",{"2":{"17":1}}],["音乐推荐",{"2":{"24":1}}],["好友推荐",{"2":{"24":1}}],["文章发布",{"2":{"181":1}}],["文章表",{"2":{"181":1}}],["文章点赞",{"2":{"24":1}}],["文档",{"2":{"181":1}}],["文档切割",{"2":{"171":1}}],["文档预处理",{"2":{"171":1}}],["文档收集",{"2":{"171":1}}],["文档收集和切割",{"0":{"171":1},"2":{"170":1}}],["文档过滤和检索",{"2":{"170":1}}],["文件路径path",{"2":{"133":1}}],["文件中添加了",{"2":{"11":1}}],["文件替换旧的的",{"2":{"11":1}}],["文件替换掉现有的",{"2":{"9":1}}],["文件读入内存就可以",{"2":{"10":1}}],["文件记录的是命令操作的日志",{"2":{"10":1}}],["文件所保存的数据库状态一致",{"2":{"9":1}}],["文件的可读性变得很差",{"2":{"11":1}}],["文件的前半部分是",{"2":{"11":1}}],["文件的时间太长",{"2":{"10":1}}],["文件的内容以恢复数据",{"2":{"9":1}}],["文件的内核缓冲区",{"2":{"9":2}}],["文件的大小会越来越大",{"2":{"9":1}}],["文件",{"2":{"9":6,"10":4,"11":4,"110":1,"111":1,"151":1,"159":1}}],["统计指定页面的",{"2":{"27":1}}],["统计页面",{"0":{"27":1},"2":{"27":1}}],["统计活跃用户的话",{"2":{"26":1}}],["统计活跃用户怎么做",{"0":{"26":1}}],["统计",{"2":{"24":1}}],["话题热度排行榜等等",{"2":{"23":1}}],["王者荣耀中的段位排行榜",{"2":{"23":1}}],["朋友圈的微信步数排行榜",{"2":{"23":1}}],["中间件课程",{"2":{"181":1}}],["中间件与拓展",{"2":{"181":1}}],["中抹掉",{"2":{"167":1}}],["中分为输入流和输出流",{"2":{"159":1}}],["中实现的方法",{"2":{"108":1}}],["中有",{"2":{"59":1}}],["中有一个叫做",{"2":{"23":1}}],["中都存在",{"2":{"58":2}}],["中字符串类型常用命令",{"2":{"31":1}}],["中的数据都恢复至内存就可以了",{"2":{"167":1}}],["中的一种基本数据类型",{"2":{"108":1}}],["中的一大利器",{"2":{"68":1}}],["中的队列主要通过",{"2":{"73":1}}],["中的",{"2":{"24":1,"58":1,"134":1,"148":1,"151":1}}],["中",{"2":{"24":1,"27":2,"65":1,"139":1,"166":1}}],["中对应的",{"2":{"22":1}}],["删除数据",{"2":{"90":1}}],["删除",{"2":{"38":1,"51":1,"85":1,"147":1}}],["删除商品就是删除",{"2":{"22":1}}],["删除操作类似",{"2":{"17":1}}],["值也不会变",{"2":{"133":1}}],["值也要相等",{"2":{"128":1,"129":1}}],["值不能被修改",{"2":{"132":1}}],["值却不相等",{"2":{"128":1}}],["值必须是相等",{"2":{"128":1}}],["值的对象",{"2":{"127":1}}],["值的长度过大或者键值对的数量过多的情况下",{"2":{"18":1}}],["值作比较",{"2":{"127":1}}],["值来判断对象加入的位置",{"2":{"127":1}}],["值传递是对基本型变量而言的",{"2":{"106":1}}],["值随机插入",{"2":{"60":1}}],["值",{"2":{"22":1,"45":1,"129":1}}],["查看变量",{"2":{"181":1}}],["查出两表完全匹配的部分",{"2":{"88":1}}],["查询增强和关联",{"2":{"170":1}}],["查询语句执行流程",{"0":{"86":1}}],["查询语句中的条件必须使用精确匹配",{"2":{"78":1}}],["查询缓存",{"2":{"84":2}}],["查询购物车信息就是遍历对应的",{"2":{"22":1}}],["查找的时候从根节点开始",{"2":{"62":1}}],["查找的最坏时间复杂度都为",{"2":{"51":1}}],["查找红黑树",{"2":{"54":1}}],["查找所有符合给定模式",{"2":{"34":1}}],["查找一个元素也需要从头到尾遍历整个链表",{"2":{"17":1}}],["与表达式",{"2":{"180":1}}],["与redo",{"0":{"164":1}}],["与其相对应的",{"2":{"143":1}}],["与",{"2":{"22":1,"181":1}}],["里面的对象",{"2":{"104":1}}],["里面",{"2":{"27":1}}],["里面增加新的",{"2":{"22":1}}],["里执行",{"2":{"10":1}}],["商品管理",{"2":{"181":1}}],["商品数量为",{"2":{"22":1}}],["商品",{"2":{"22":1}}],["购物车信息建议使用",{"2":{"22":1}}],["购物车信息用",{"0":{"22":1}}],["购物车等",{"2":{"14":1}}],["来进行捕获不建议通过catch捕获",{"2":{"139":1}}],["来进行捕获",{"2":{"139":1}}],["来做的",{"2":{"121":1}}],["来存储",{"2":{"117":1}}],["来存储对象数据即可",{"2":{"21":1}}],["来使用来自外部的用户自定义类",{"2":{"69":1}}],["来作为判断条件",{"2":{"57":1}}],["来定位元素下标的",{"2":{"56":1}}],["来实现",{"2":{"44":1}}],["来完成的",{"2":{"9":1}}],["我们不需要针对每个目标类都单独创建一个代理类",{"2":{"148":1}}],["我们达到了功能增强的目的",{"2":{"147":1}}],["我们就可以通过代理类屏蔽对目标对象的访问",{"2":{"147":1}}],["我们使用代理对象来代替对真实对象",{"2":{"146":1}}],["我们即使不处理不受检查异常也可以正常通过编译",{"2":{"140":1}}],["我们没办法通过",{"2":{"139":1}}],["我们每次调用replace等方法",{"2":{"133":1}}],["我们以",{"2":{"127":1}}],["我们是无法将",{"2":{"118":1}}],["我们编写的java程序必须要在jre才能运行",{"2":{"112":1}}],["我们编写的java代码",{"2":{"110":1}}],["我们可以直接代理实现类",{"2":{"148":1}}],["我们可以将string",{"2":{"145":1}}],["我们可以将高级编程语言按照程序的执行方式分为两种",{"2":{"111":1}}],["我们可以轻松实现两个位置距离的计算",{"2":{"19":1}}],["我们的数据都被存放在了各种表中",{"2":{"82":1}}],["我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射",{"2":{"69":1}}],["我们需要统计⼀篇⽂章中有多少个不重复的单词",{"2":{"44":1}}],["我们经常会遇到与统计相关的功能需求",{"2":{"27":1}}],["我们知道计算机是二进制的",{"2":{"120":1}}],["我们知道",{"2":{"26":1}}],["我们建议使用",{"2":{"21":1}}],["消除传递依赖",{"2":{"83":1}}],["消除部分依赖",{"2":{"83":1}}],["消费者用zrangebyscore指令获取n秒之前的数据轮询进行处理",{"2":{"29":1}}],["消息内容作为key",{"2":{"29":1}}],["消息队列入门",{"2":{"181":1}}],["消息队列初步",{"2":{"181":1}}],["消息队列",{"2":{"13":1,"14":2}}],["消耗的内存约是",{"2":{"21":1}}],["节点",{"2":{"49":1}}],["节点越少",{"2":{"17":1}}],["节省网络流量",{"2":{"21":1}}],["是无法恢复的",{"2":{"167":1}}],["是追加日志",{"2":{"167":1}}],["是mysql数据库中的一种日志文件",{"2":{"166":1}}],["是线程安全的",{"2":{"131":1}}],["是如何保证数据不丢失的",{"0":{"89":1}}],["是事务性存储引擎",{"2":{"75":1}}],["是⼀个基于数组的",{"2":{"73":1}}],["是⼀个基于哈希表的键值对集合",{"2":{"72":1}}],["是⼀个⽆界队列",{"2":{"73":1}}],["是⼀个双向链表",{"2":{"72":1}}],["是",{"0":{"167":1},"2":{"67":1,"89":1,"135":1}}],["是使用",{"2":{"59":1}}],["是直接在操作方法上加",{"2":{"59":1}}],["是奇数",{"2":{"56":1}}],["是通过",{"2":{"56":1}}],["是则向树中插入节点",{"2":{"52":1}}],["是基于红⿊树实现的",{"2":{"63":1}}],["是基于数组+链表+红⿊树实现的",{"2":{"63":1}}],["是基于",{"2":{"45":1}}],["是基于动态数组实现的",{"2":{"45":1}}],["是在",{"2":{"41":1}}],["是的话就返回遍历",{"2":{"38":1}}],["是一个32位的int类型的数值",{"2":{"55":1}}],["是一块连续的内存空间",{"2":{"36":1}}],["是一种结合信息检索技术和",{"2":{"169":1}}],["是一种面向对象语言",{"2":{"118":1}}],["是一种无序集合",{"2":{"24":1}}],["是一种有名的基数计数概率算法",{"2":{"19":1}}],["是一种基于有序链表的数据结构",{"2":{"17":1}}],["是一种基于内存的数据库",{"2":{"13":1}}],["是否也一定为",{"0":{"129":1}}],["是否是同一个对象",{"2":{"125":1}}],["是否可被",{"0":{"97":1}}],["是否执行过",{"2":{"84":1}}],["是否支持聚集索引",{"2":{"76":1}}],["是否支持mvcc",{"2":{"76":1}}],["是否支持外键",{"2":{"76":1}}],["是否支持事务",{"2":{"76":1}}],["是否支持行级锁",{"2":{"76":1}}],["是否支持随机访问",{"2":{"36":1}}],["是否为树节点",{"2":{"52":1}}],["是否存在",{"2":{"34":1}}],["是redis提供的一个非常有用的命令",{"2":{"32":1}}],["是用来做基数统计的算法",{"2":{"27":1}}],["是对对象的每个字段单独存储",{"2":{"21":1}}],["存放integer要写另外⼀个list接口",{"2":{"145":1}}],["存放string类型要写⼀个list接口",{"2":{"145":1}}],["存放的数据不能重复的场景",{"2":{"24":1}}],["存放的是整个对象",{"2":{"21":1}}],["存在一定空间浪费",{"2":{"36":1}}],["存在是删除",{"2":{"34":1}}],["存储键值对",{"2":{"180":1}}],["存储列表",{"2":{"180":1}}],["存储内容",{"2":{"164":1}}],["存储在这个value数组里面的",{"2":{"132":1}}],["存储引擎层提供数据存储和提取的具体实现",{"2":{"84":1}}],["存储引擎",{"0":{"74":1},"1":{"75":1,"76":1,"77":1,"78":1,"79":1,"80":1},"2":{"84":1}}],["存储",{"2":{"22":1}}],["存储更好呢",{"0":{"22":1}}],["存储具有多层嵌套的对象时也方便很多",{"2":{"21":1}}],["存储相对来说更加节省内存",{"2":{"21":1}}],["存储的是序列化后的对象数据",{"2":{"21":1}}],["存储的是连续的二进制数字",{"2":{"19":1,"26":1}}],["存储对象数据更好呢",{"0":{"21":1}}],["存储地理位置信息的场景",{"2":{"14":1}}],["按1nf要求",{"2":{"83":1}}],["按照属性是否相等来判断",{"2":{"124":1}}],["按照重写逻辑输出对象值",{"2":{"124":1}}],["按照3nf的要求",{"2":{"83":1}}],["按照bitmap的顺序",{"2":{"20":1}}],["按照插入顺序排序",{"2":{"15":1}}],["按位输出",{"2":{"20":1}}],["从各种来源",{"2":{"171":1}}],["从技术角度看",{"2":{"169":1}}],["从内存中读取出来之后需要进行反序列化",{"2":{"154":1}}],["从",{"2":{"148":1}}],["从⽽实现插⼊的顺序或访问顺序",{"2":{"61":1}}],["从任一节点到其子树中每个叶子节点的路径都包含相同数量的黑色节点",{"2":{"49":1}}],["从冲突的位置拉一个链表",{"2":{"48":1}}],["从大到小排序",{"2":{"23":1}}],["从小到大排序",{"2":{"23":1}}],["从0开始计数",{"2":{"20":1}}],["从而保证数据的一致性",{"2":{"166":1}}],["从而达到防止sql注入效果",{"2":{"91":1}}],["从而导致元素的丢失",{"2":{"58":1}}],["从而允许在高层快速跳过一些元素",{"2":{"16":1}}],["从而避免阻塞主进程",{"2":{"9":1}}],["尤其是在内存有限的情况下",{"2":{"20":1}}],["稠密矩阵",{"2":{"19":1}}],["稀疏矩阵",{"2":{"19":1}}],["采用wal策略提升写入性能",{"2":{"164":1}}],["采用安全失败机制的集合容器",{"2":{"39":1}}],["采用两种方式计数",{"2":{"19":1}}],["采用ziplist编码",{"2":{"16":1}}],["优化项目",{"2":{"181":1}}],["优化数据库连接",{"2":{"181":1}}],["优化器根据自己的优化算法进行选择执行效率最好的一个方案",{"2":{"86":1}}],["优化器对查询进行优化",{"2":{"84":1}}],["优化器",{"2":{"84":2}}],["优化改进得来",{"2":{"19":1}}],["优点",{"2":{"75":1,"147":1,"150":1}}],["优点是可以根据键的哈希值快速查找到值",{"2":{"72":1}}],["优点是插⼊和删除元素的时候只需要改变节点的",{"2":{"72":1}}],["优点是访问速度快",{"2":{"72":1}}],["优点是丢失数据少",{"2":{"11":1}}],["优点是数据恢复速度快",{"2":{"11":1}}],["优先级队列",{"2":{"73":1}}],["优劣",{"0":{"72":1}}],["基础版",{"2":{"181":1}}],["基础章节",{"2":{"181":1}}],["基础",{"2":{"181":4}}],["基础篇",{"2":{"181":1}}],["基础语法",{"2":{"180":1}}],["基础语法与核心特性",{"0":{"178":1},"1":{"179":1,"180":1}}],["基本概念",{"2":{"164":1,"165":1,"181":1}}],["基本数据类型没有equal方法",{"2":{"125":1}}],["基数估计就是在误差可接受的范围内",{"2":{"27":1}}],["基数",{"2":{"27":1}}],["基数统计",{"2":{"13":1,"19":1}}],["基于递归分割策略",{"2":{"171":1}}],["基于语义边界",{"2":{"171":1}}],["基于固定大小",{"2":{"171":1}}],["基于聚簇索引建立的",{"2":{"75":1}}],["基于元素的",{"2":{"45":1}}],["基于拷贝内容的优点是避免了concurrent",{"2":{"39":1}}],["基于",{"2":{"19":2}}],["偏移量",{"2":{"19":1,"26":1}}],["数组",{"2":{"156":1}}],["数组⻓度",{"2":{"56":1}}],["数组大小",{"2":{"48":1}}],["数组的容量是在定义的时候确定的",{"2":{"37":1}}],["数组中每个元素的下标叫做",{"2":{"19":1,"26":1}}],["数值范围0",{"0":{"20":1}}],["数据结构",{"2":{"181":1}}],["数据结构不同",{"2":{"36":1}}],["数据传输过程类似于水流",{"2":{"159":1}}],["数据输入到计算机内存的过程即输入",{"2":{"159":1}}],["数据类型",{"2":{"108":1,"180":1}}],["数据库实战",{"2":{"181":1}}],["数据库优化",{"2":{"181":1}}],["数据库进阶",{"2":{"181":1}}],["数据库进阶与中间件",{"2":{"181":1}}],["数据库设计",{"2":{"181":1}}],["数据库书籍",{"2":{"181":1}}],["数据库",{"2":{"181":1}}],["数据库基础",{"2":{"181":1}}],["数据库等",{"2":{"171":1}}],["数据库重启后",{"2":{"167":1}}],["数据库名称",{"2":{"91":1}}],["数据库备份和恢复",{"2":{"90":1}}],["数据库的三大范式",{"0":{"83":1}}],["数据页结构",{"0":{"79":1}}],["数据元素通过映射关系",{"2":{"48":1}}],["数据存储在mysql表中",{"2":{"27":1}}],["数据量巨大的场景还是",{"2":{"24":1}}],["数据能修改吗",{"2":{"10":1}}],["数据在子进程的内存数据就跟主进程的内存数据不一致了",{"2":{"9":1}}],["数据可能会丢失",{"2":{"9":1}}],["看作是一个存储二进制数字",{"2":{"19":1,"26":1}}],["本身就是线程安全的",{"2":{"133":1}}],["本身会极大的节省储存空间",{"2":{"19":1,"26":1}}],["本地方法是指在",{"2":{"108":1}}],["本来int数字占4字节32位",{"2":{"19":1}}],["位",{"2":{"108":1}}],["位来表示某个元素对应的值或者状态",{"2":{"19":1,"26":1}}],["位图",{"2":{"13":1,"19":1}}],["只会记录未刷盘的日志",{"2":{"167":1}}],["只会根据输入元素来计算基数",{"2":{"27":1}}],["只维护一个代理类",{"2":{"147":1}}],["只能被截断",{"2":{"120":1}}],["只有两个值",{"2":{"117":1}}],["只有值传递",{"2":{"106":1}}],["只有在",{"2":{"31":1}}],["只要crash后读取redo",{"2":{"167":1}}],["只要刷入磁盘的数据",{"2":{"167":1}}],["只要强引用还存在",{"2":{"115":1}}],["只要在不同平台上安装对应的jvm",{"2":{"110":1}}],["只要你在编写完代码后",{"2":{"109":1}}],["只要有一个不同就叫做参数列表不同",{"2":{"96":1}}],["只要redolog",{"2":{"89":1}}],["只要其中一个表存在匹配",{"2":{"88":1}}],["只要它们不冲突",{"2":{"77":1}}],["只要满足上面条件的任意一个",{"2":{"10":1}}],["只支持表级锁",{"2":{"76":1}}],["只不过需要复制元素到新的数组",{"2":{"72":1}}],["只保留低位值",{"2":{"56":1}}],["只重写元素的",{"0":{"53":1}}],["只需要",{"2":{"19":1}}],["只需要一个",{"2":{"19":1,"26":1}}],["只是实现了这个算法并提供了一些开箱即用的",{"2":{"19":1}}],["以便在系统发生故障时能够恢复未完成的事务",{"2":{"166":1}}],["以便在需要回滚时可以恢复数据",{"2":{"163":1}}],["以释放磁盘空间",{"2":{"166":1}}],["以事件形式记录",{"2":{"165":1}}],["以此来保证数据的完整性",{"2":{"163":1}}],["以list接口为例",{"2":{"145":1}}],["以节省内存",{"2":{"108":1}}],["以上述sql为例使用preparedstatement预编译后的sql为",{"2":{"91":1}}],["以上的方案结果精确",{"2":{"27":1}}],["以这条",{"2":{"86":1}}],["以提供更灵活的并发控制机制",{"2":{"78":1}}],["以确保跨平台的浮点数计算的一致性",{"2":{"108":1}}],["以确保锁定的是单一记录",{"2":{"78":1}}],["以确保一组测试中有较高的代码覆盖率",{"2":{"69":1}}],["以加速读操作",{"2":{"75":1}}],["以帮助程序员编写正确的代码",{"2":{"69":1}}],["以及cglib的动态代理",{"2":{"148":1}}],["以及抽象方法",{"2":{"108":1}}],["以及意向锁等",{"2":{"78":1}}],["以及优先级队列priorityqueue",{"2":{"70":1}}],["以及",{"2":{"59":1}}],["以保证树的平衡",{"2":{"57":1}}],["以下是对这两种行锁的详细解释",{"2":{"78":1}}],["以下是具体分析",{"2":{"77":1}}],["以下是setex命令的工作原理",{"2":{"33":1}}],["以下是setnx命令的工作原理",{"2":{"32":1}}],["以下是使用bitmap排序的步骤",{"2":{"20":1}}],["以达到既节省内存又保证访问效率的目的",{"2":{"18":1}}],["以二进制的方式写入磁盘",{"2":{"8":1}}],["对于三者使用的总结",{"2":{"131":1}}],["对于复合数据类型",{"2":{"125":1}}],["对于基本数据类型",{"2":{"125":1}}],["对于软引用关联着的对象",{"2":{"115":1}}],["对于innodb",{"2":{"76":1}}],["对于框架来说实际是影响不大的",{"2":{"69":1}}],["对于非常大的数据集是不切实际的",{"2":{"27":1}}],["对象型的是",{"2":{"155":1}}],["对象在进行网络传输",{"2":{"154":1}}],["对象保存在文件中",{"2":{"153":1}}],["对象比如将",{"2":{"153":1}}],["对象封装的异常信息",{"2":{"141":1}}],["对象进行拷贝",{"2":{"104":1}}],["对象的相等一般比较的是内存中存放的内容是否相等",{"2":{"95":1}}],["对象的相等和引用相等的区别",{"0":{"95":1}}],["对象的编码也会从ziplist变为hashtable",{"2":{"18":1}}],["对象引用存放在栈内存中",{"2":{"94":1}}],["对象引用指向对象实例",{"2":{"94":1}}],["对象实例在堆内存中",{"2":{"94":1}}],["对象实体与对象引用有何不同",{"0":{"94":1}}],["对象",{"2":{"59":1,"67":1,"153":1}}],["对",{"2":{"19":1}}],["对数据的读写操作都是在内存中完成",{"2":{"13":1}}],["对数据库进行了至少",{"2":{"10":3}}],["即使redo",{"2":{"166":1}}],["即使数据是有序的",{"2":{"17":1}}],["即真",{"2":{"108":1}}],["即不存在变量a指向变量b",{"2":{"106":1}}],["即不能存在",{"2":{"83":1}}],["即对象的浅拷贝会对",{"2":{"104":1}}],["即常量",{"2":{"102":1}}],["即",{"2":{"39":1,"159":1}}],["即可",{"2":{"22":1}}],["即可得到排序后的结果",{"2":{"20":1}}],["即至少需要40亿位",{"2":{"20":1}}],["即原本保存在ziplist中的所有键值对会被转移到字典中",{"2":{"18":1}}],["此问题在",{"2":{"58":1}}],["此外",{"2":{"18":1,"78":1}}],["此时sql语句结构已固定",{"2":{"91":1}}],["此时redo",{"2":{"87":1}}],["此时执行",{"2":{"58":1}}],["此时如果主线程执行读操作",{"2":{"10":1}}],["此时子进程和父进程是共享同一片内存数据的",{"2":{"10":1}}],["此时这个",{"2":{"9":1}}],["此时父子进程共享物理内存",{"2":{"9":1}}],["此时数据并没有写入到硬盘",{"2":{"9":2}}],["字段类型设计",{"2":{"181":1}}],["字符流",{"2":{"180":1}}],["字符",{"2":{"108":1}}],["字符串操作",{"2":{"180":1}}],["字符串操作命令",{"0":{"31":1},"1":{"32":1,"33":1}}],["字符串比较",{"2":{"137":1}}],["字符串替换",{"2":{"137":1}}],["字符串常量池",{"2":{"135":1}}],["字符串常量池优化",{"2":{"133":1}}],["字符串的值是否相等",{"2":{"134":1}}],["字符串",{"2":{"13":1,"14":1,"15":1,"82":1}}],["字节流",{"2":{"180":1}}],["字节码文件",{"2":{"110":1}}],["字节",{"2":{"79":1,"108":1}}],["字典的值为另一个字符串对象",{"2":{"18":1}}],["保存的是全量的日志",{"2":{"167":1}}],["保存了原键值对的值",{"2":{"18":1}}],["保存了原键值对的键",{"2":{"18":1}}],["保证数据的一致性",{"2":{"166":1}}],["保证事务的持久性",{"2":{"165":1}}],["保证了事务的原子性和一致性",{"2":{"163":1}}],["保证持久化磁盘就能确保mysql异常重启后回复数据",{"2":{"89":1}}],["保证原子性",{"2":{"83":1}}],["保证每个元素唯⼀",{"2":{"45":1}}],["保持元素的插⼊顺序",{"2":{"45":1}}],["保持链表的有序性",{"2":{"17":1}}],["且自增的log",{"2":{"166":1}}],["且不侵入原代码",{"2":{"147":1}}],["且键值对数量少于512",{"2":{"18":1}}],["且是异步的",{"2":{"9":1}}],["先看看什么是不可变的对象",{"2":{"132":1}}],["先看看什么是编译型语言和解释型语言",{"2":{"111":1}}],["先进行hashcode",{"2":{"129":1}}],["先查询到",{"2":{"87":1}}],["先连接器检查该语句是否有权限",{"2":{"86":1}}],["先校验这个",{"2":{"84":1}}],["先找到要删除的节点",{"2":{"17":1}}],["先将命令写入到",{"2":{"9":2}}],["随着类的加载而加载",{"2":{"157":1}}],["随着执行的写操作命令越来越多",{"2":{"9":1}}],["随机获取指定集合中指定数量的元素",{"2":{"25":1}}],["随机移除并获取指定集合中一个或多个元素",{"2":{"25":1}}],["随机点名等等",{"2":{"24":1}}],["随机结果高于某个固定概率p",{"2":{"17":1}}],["首先明确字节流适用于任何场景",{"2":{"160":1}}],["首先通过词法分析识别出各个字符串的意义",{"2":{"84":1}}],["首先要满足第二范式",{"2":{"83":1}}],["首先要满足第一范式",{"2":{"83":1}}],["首先要找到合适的插入位置",{"2":{"17":1}}],["首先进行哈希值的扰动",{"2":{"52":1}}],["首先在顶层索引进行查找",{"2":{"17":1}}],["其操作与字节流基本都一样",{"2":{"160":1}}],["其后可接零个或多个",{"2":{"142":1}}],["其他所有异常称为检查",{"2":{"140":1}}],["其他事务无法对表中的任何数据进行写入或修改",{"2":{"77":1}}],["其实会在堆内存中创建了一个新的对象",{"2":{"133":1}}],["其实不是的",{"2":{"133":1}}],["其实",{"2":{"127":1}}],["其实我们的",{"2":{"85":1}}],["其容量是原来的两倍",{"2":{"57":1}}],["其中抽象方法没有具体的实现",{"2":{"102":1}}],["其中学生所在院校依赖于学号",{"2":{"83":1}}],["其中",{"2":{"33":1}}],["其中字典的键为字符串对象",{"2":{"18":1}}],["其中key是字符串类型",{"2":{"15":1}}],["其时间复杂度也是o",{"2":{"17":1}}],["最后",{"2":{"112":1}}],["最后⼀个加⼊栈的元素会成为第⼀个被移除的元素",{"2":{"73":1}}],["最后所有元素处理完成后",{"2":{"52":1}}],["最终在底层链表中找到目标元素或者确认元素不存在",{"2":{"17":1}}],["最坏情况下为o",{"2":{"16":1}}],["例如输出错误信息",{"2":{"108":1}}],["例如运算符重载",{"2":{"107":1}}],["例如临键锁",{"2":{"78":1}}],["例如",{"2":{"17":1,"20":1,"83":2,"139":1,"163":1}}],["顶层索引链表的节点数量远少于底层原始链表",{"2":{"17":1}}],["压缩列表适用于数据量小",{"2":{"16":1}}],["综上所述",{"2":{"16":1,"18":1}}],["达到快速定位的目的",{"2":{"16":1}}],["ny8ikbiosottcgtymqbjlul9gmod0p0tjlzdmnbv70",{"2":{"169":1}}],["number",{"2":{"166":1}}],["null",{"2":{"45":1,"49":1,"52":1,"55":1,"58":1,"155":1}}],["native",{"2":{"108":1}}],["name",{"2":{"87":3}}],["newinstance",{"2":{"113":1}}],["new",{"0":{"136":1},"2":{"94":2,"111":4,"115":1}}],["newcap",{"2":{"57":1}}],["next",{"2":{"38":1}}],["noclassdeffounderror",{"2":{"139":1}}],["not",{"2":{"32":1}}],["no意味着不由",{"2":{"9":1}}],["n",{"2":{"16":1,"17":1,"36":4,"51":1,"52":1,"56":2,"94":2,"171":1}}],["跳表的插入和删除操作同样高效",{"2":{"17":1}}],["跳表以空间换时间的方式优化了传统单链表的效率",{"2":{"17":1}}],["跳表",{"2":{"17":1}}],["跳表中的每一层都是一个有序链表",{"2":{"16":1,"17":1}}],["跳表能够提供平均o",{"2":{"16":1}}],["跳表是一种多层次的链表结构",{"2":{"16":1}}],["底层数组的容量",{"2":{"56":1}}],["底层就是基于",{"2":{"44":1}}],["底层采用两种数据结构",{"2":{"16":1}}],["底层是双向链表",{"2":{"15":1}}],["类与对象",{"2":{"180":1}}],["类常用方法有哪些",{"0":{"141":1}}],["类定义错误",{"2":{"139":1}}],["类有两个重要的子类",{"2":{"139":1}}],["类的常用方法有哪些",{"0":{"137":1}}],["类似",{"2":{"115":1}}],["类似于java中的hashset",{"2":{"15":1}}],["类似于java中的hashmap结构",{"2":{"15":1}}],["类似于java中的linkedlist",{"2":{"15":1}}],["类浏览器和可视化开发环境",{"2":{"69":1}}],["类",{"2":{"38":1,"135":1,"139":1}}],["类型数组",{"2":{"137":1}}],["类型的变量可以存储任意的",{"2":{"108":1}}],["类型的应用场景",{"2":{"14":2}}],["类型占用的空间较小",{"2":{"108":1}}],["类型实现的消息队列",{"2":{"14":1}}],["类型",{"2":{"14":3,"118":1}}],["相应就大大提高了执行速度",{"2":{"127":1}}],["相等的对象是否真的相同",{"2":{"127":1}}],["相等的两个对象",{"2":{"53":1}}],["相当于将基本类型包装起来",{"2":{"118":1}}],["相当于压缩了文件",{"2":{"9":1}}],["相反",{"2":{"107":1}}],["相比于静态代理来说",{"2":{"148":1}}],["相比于基于",{"2":{"14":1}}],["相比之下",{"2":{"107":1}}],["相同",{"0":{"129":1}}],["相同的方法有不同的參数列表",{"2":{"101":1}}],["相同键会覆盖掉原来的键",{"2":{"44":1}}],["相关的一些",{"2":{"23":1}}],["500",{"2":{"181":1}}],["512",{"2":{"171":1}}],["5中引⼊的⼀个新特性",{"2":{"145":1}}],["5倍的新数组",{"2":{"37":1}}],["5",{"2":{"14":1,"27":3,"108":1,"118":1}}],["39",{"2":{"108":1}}],["38",{"2":{"108":1}}],["37",{"2":{"108":1}}],["33",{"2":{"108":1}}],["32bit",{"2":{"117":2}}],["32",{"2":{"108":1}}],["31",{"2":{"108":1}}],["3种redis特殊数据类型",{"0":{"19":1},"1":{"20":1}}],["3",{"0":{"151":1},"2":{"14":1,"27":2,"36":1,"72":1,"87":1,"88":1,"108":1,"118":1,"144":1,"181":4}}],["300",{"2":{"10":1}}],["undo",{"0":{"162":1,"164":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1},"2":{"163":5,"164":4}}],["unchecked",{"2":{"139":1,"140":1}}],["unicode",{"2":{"108":1}}],["unique",{"2":{"27":1}}],["uuid",{"2":{"90":1}}],["update",{"2":{"76":1,"87":1}}],["util",{"2":{"39":1,"71":1}}],["util包下的集合类都是快速失败的",{"2":{"38":1}}],["uv",{"0":{"27":1},"2":{"14":1,"24":1,"27":2}}],["user",{"2":{"79":1,"87":1}}],["used",{"2":{"2":1}}],["usedata",{"2":{"2":3}}],["usage",{"2":{"2":1}}],["海量数据基数统计的场景",{"2":{"14":1}}],["896043488029600",{"2":{"181":1}}],["8中汉字占3个字节",{"2":{"160":1}}],["8中使用cas+synchronized",{"2":{"59":1}}],["8bit",{"2":{"117":1}}],["8及以上版本",{"2":{"102":1}}],["8的数据结构是数组+链表+红黑树",{"2":{"48":1}}],["8",{"2":{"14":1,"26":1,"27":2,"48":1,"58":3,"63":1,"65":1,"79":1,"108":1,"118":1}}],["排序场景",{"2":{"14":1}}],["共同点",{"2":{"102":1}}],["共同粉丝",{"2":{"24":1}}],["共同好友",{"2":{"24":1}}],["共同关注",{"2":{"14":1,"24":1}}],["共享",{"2":{"14":1}}],["场景",{"2":{"14":1,"38":1,"39":1}}],["差集+交集",{"2":{"24":1}}],["差集",{"2":{"14":1,"24":2}}],["交集",{"2":{"14":1,"24":3,"88":1}}],["200",{"2":{"181":1}}],["2之后",{"2":{"115":1}}],["27",{"2":{"108":1}}],["26",{"2":{"108":1}}],["23",{"2":{"108":1}}],["21",{"2":{"108":1}}],["2^7",{"2":{"108":2}}],["2^64",{"2":{"27":1}}],["2",{"0":{"87":1,"150":1,"172":1},"2":{"14":5,"27":2,"36":1,"41":1,"56":1,"58":1,"72":1,"87":1,"88":1,"100":1,"108":1,"118":1,"132":1,"136":2,"144":1,"147":1,"181":4}}],["信息的最小存储单元都是字节",{"2":{"160":1}}],["信息等",{"2":{"14":1}}],["信号函数执行完后",{"2":{"9":1}}],["信号是进程间通讯的一种方式",{"2":{"9":1}}],["常用依赖",{"2":{"181":1}}],["常用",{"2":{"180":1}}],["常用于java反射机制",{"2":{"124":1}}],["常用于判断条件",{"2":{"108":1}}],["常用于缓存",{"2":{"13":1}}],["常见应用场景",{"0":{"154":1}}],["常见的解释性语言有",{"2":{"111":1}}],["常见的编译性语言有",{"2":{"111":1}}],["常见存储引擎",{"0":{"75":1}}],["常见集合框架",{"0":{"70":1}}],["常⽤的集合类有",{"2":{"72":1}}],["常规计数",{"2":{"14":1}}],["缓存",{"2":{"181":2}}],["缓存使用场景",{"2":{"181":1}}],["缓存的范围区间的大小只是在性能和资源之间的权衡",{"2":{"122":1}}],["缓存相同数量的对象数据",{"2":{"21":1}}],["缓存对象",{"2":{"14":2}}],["缓冲区的数据写入到",{"2":{"9":2}}],["缓冲区",{"2":{"9":3}}],["过期机制",{"2":{"33":1}}],["过期删除机制等等",{"2":{"13":1}}],["过程中",{"2":{"10":1}}],["过程是由后台子进程",{"2":{"9":1}}],["发布",{"2":{"13":1}}],["哨兵模式",{"2":{"13":1}}],["多人协作",{"2":{"181":1}}],["多版本并发控制",{"2":{"164":1}}],["多个类都是从如下",{"2":{"159":1}}],["多个节点可能同时分配自增",{"2":{"90":1}}],["多处运行的原因所在",{"2":{"112":1}}],["多重继承和强制类型转换等",{"2":{"107":1}}],["多态是同一个行为具有多个不同表现形式的能力",{"2":{"101":1}}],["多态",{"0":{"101":1},"2":{"98":1,"180":1}}],["多对多",{"2":{"82":1}}],["多线程基础",{"2":{"180":1}}],["多线程操作字符串缓冲区下操作大量数据",{"2":{"131":1}}],["多线程同时执行",{"2":{"58":1}}],["多线程的",{"2":{"58":1}}],["多线程下扩容死循环",{"2":{"58":1}}],["多线程之间会共享内存",{"2":{"9":1}}],["多数情况下",{"2":{"36":1}}],["多种集群方案",{"2":{"13":1}}],["脚本",{"2":{"13":1}}],["lsn",{"2":{"166":1}}],["lang",{"2":{"139":1}}],["last",{"2":{"73":1}}],["left",{"0":{"88":1},"2":{"88":1}}],["length",{"2":{"56":1,"137":1}}],["long",{"2":{"108":1,"117":2,"118":1,"122":1}}],["locks",{"2":{"78":2}}],["logback",{"2":{"181":1}}],["log4j",{"2":{"181":1}}],["log进行重放",{"2":{"167":1}}],["log进入",{"2":{"87":1}}],["log的主要作用是记录数据库中每个事务的修改操作",{"2":{"166":1}}],["log的区别",{"0":{"164":1}}],["log文件后",{"2":{"166":1}}],["log文件的大小是有限的",{"2":{"166":1}}],["log文件",{"2":{"166":1}}],["log文件中的",{"2":{"166":1}}],["log文件中的redo",{"2":{"166":1}}],["log文件中",{"2":{"166":2}}],["log有什么区别",{"0":{"165":1}}],["log和redo",{"0":{"165":1},"2":{"164":1,"165":1}}],["log则负责事务的回滚和实现mvcc",{"2":{"163":1}}],["log会记录一个delete操作",{"2":{"163":1}}],["log记录了记录了事务对数据库所做的更改的相反操作",{"2":{"163":1}}],["log回滚日志",{"2":{"163":1}}],["log恢复到断电前的时刻",{"2":{"163":1}}],["log恢复数据",{"2":{"87":1}}],["log保证了事务的持久性",{"2":{"163":1}}],["log是innodb存储引擎中实现事务持久性和原子性的关键机制",{"2":{"164":1}}],["log是mysql的回滚日志",{"2":{"163":1}}],["log是mysql的二进制日志",{"2":{"163":1}}],["log是重做日志",{"2":{"163":1}}],["log重做日志",{"2":{"163":1}}],["log二进制日志",{"2":{"163":1}}],["log日志",{"0":{"162":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1}}],["log后",{"2":{"87":1}}],["log直接提交",{"2":{"87":1}}],["log为提交状态",{"2":{"87":1}}],["log",{"0":{"162":2,"164":1,"166":1,"167":1},"1":{"163":2,"164":2,"165":2,"166":2,"167":2},"2":{"87":2,"163":3,"164":6,"165":7,"166":13,"167":12}}],["loglog",{"2":{"19":1}}],["logn",{"2":{"16":1,"17":1,"51":1,"63":1}}],["lt",{"2":{"48":1,"78":1}}],["liaoxuefeng",{"2":{"181":1}}],["like",{"2":{"174":1}}],["like等",{"2":{"78":1}}],["library",{"2":{"150":1}}],["line",{"2":{"174":1}}],["linux",{"2":{"112":1}}],["linkedhashmap",{"0":{"61":1},"2":{"61":1,"72":2}}],["linkedlist每个节点",{"2":{"36":1}}],["linkedlist基于链表",{"2":{"36":2}}],["linkedlist基于链表实现",{"2":{"36":1}}],["linkedlist基于双向链表实现",{"2":{"36":1}}],["linkedlist更利于增删",{"2":{"36":1}}],["linkedlist",{"0":{"36":1},"2":{"36":1,"70":1,"72":2,"73":1}}],["lifo",{"2":{"73":1}}],["list",{"0":{"35":1},"1":{"36":1,"37":1,"38":1,"39":1,"40":1,"41":1,"42":1},"2":{"7":1,"13":1,"14":3,"15":1,"17":1,"40":1,"65":1,"70":2,"71":1,"176":1}}],["lpop消费消息",{"2":{"28":1}}],["llc",{"2":{"19":1}}],["lua",{"2":{"13":1}}],["持久化",{"2":{"13":1}}],["持久化的优点",{"2":{"11":1}}],["并以二进制格式保存在磁盘上",{"2":{"163":1}}],["并加载到",{"2":{"148":1,"151":1}}],["并不常见",{"2":{"108":1}}],["并不是一个开发环境",{"2":{"112":1}}],["并不是原对象本身",{"2":{"106":1}}],["并不是",{"2":{"19":1}}],["并非所有元素都必须是对象",{"2":{"107":1}}],["并拷贝属性指向的动态分配的内存",{"2":{"104":1}}],["并能扩展新的能力",{"2":{"100":1}}],["并管理连接的权限验证和维持",{"2":{"84":1}}],["并发时",{"2":{"58":1}}],["并发修改",{"2":{"39":1}}],["并指定该键值对的过期时间",{"2":{"33":1}}],["并返回其引用",{"2":{"135":1}}],["并返回1",{"2":{"32":1}}],["并返回0",{"2":{"32":1}}],["并将",{"2":{"31":1}}],["并且也不需要我们必须实现接口",{"2":{"148":1}}],["并且可以不需要针对每个目标类都创建一个代理类",{"2":{"151":1}}],["并且可以在目标方法执行前后做一些自己想做的事情",{"2":{"147":1}}],["并且可能随着元素的添加或删除⽽改变",{"2":{"45":1}}],["并且为其添加了属性和方法",{"2":{"118":1}}],["并且在默认情况下使用行级锁",{"2":{"77":1}}],["并且在遍历过程中使用一个",{"2":{"38":1}}],["并且有较高的并发读写频率",{"2":{"75":1}}],["并且不保留键值对的插⼊顺序",{"2":{"72":1}}],["并且保证了元素的顺序",{"2":{"63":1}}],["并且是很小的",{"2":{"27":1}}],["并且",{"2":{"19":1,"21":1,"75":1}}],["并且每个节点都包含指向同层级下一个节点的指针以及指向下一层对应节点的down指针",{"2":{"17":1}}],["并且层级越高",{"2":{"16":1,"17":1}}],["并且对数据类型的操作都是原子性的",{"2":{"13":1}}],["并集和差集的场景",{"2":{"24":1}}],["并集",{"2":{"14":1}}],["并逐一把内存数据的键值对转换成一条命令",{"2":{"9":1}}],["流操作要分为字节流操作和字符流操作呢",{"2":{"160":1}}],["流为什么要分为字节流和字符流呢",{"0":{"160":1}}],["流的",{"2":{"159":1}}],["流在",{"2":{"159":1}}],["流了解吗",{"0":{"159":1}}],["流是",{"2":{"65":1}}],["流程控制",{"2":{"180":1}}],["流程",{"0":{"52":1}}],["流",{"2":{"13":1,"65":1,"159":1,"180":1}}],["html",{"2":{"181":1}}],["http",{"2":{"181":1}}],["httpservlet",{"2":{"181":1}}],["https",{"2":{"181":6}}],["hikaricp",{"2":{"181":1}}],["highlighted",{"2":{"174":2}}],["highlighting",{"0":{"174":1},"2":{"174":2}}],["head",{"2":{"181":1}}],["header",{"2":{"79":2}}],["helloworld",{"2":{"180":1}}],["home",{"2":{"180":1}}],["h",{"2":{"52":2,"55":3}}],["hyperloglog更适合一些",{"2":{"24":1}}],["hyperloglog",{"0":{"27":1},"2":{"13":1,"14":1,"19":4,"27":9}}],["hashcode方法主要是用来提升对象比较的效率",{"2":{"129":1}}],["hashcode",{"0":{"53":1,"126":1,"127":1,"128":1},"2":{"45":1,"52":1,"53":2,"55":1,"124":2,"126":1,"127":7,"128":4,"129":2}}],["hashmap是无序的",{"2":{"60":1}}],["hashmap是线程安全的吗",{"0":{"58":1}}],["hashmap内部节点是否有序",{"0":{"60":1}}],["hashmap不是线程安全的",{"2":{"58":1}}],["hashmap的扩容机制",{"0":{"57":1}}],["hashmap的哈希函数是先拿到",{"2":{"55":1}}],["hashmap的hash函数",{"0":{"55":1}}],["hashmap怎么get查找元素",{"0":{"54":1}}],["hashmap为什么要用红黑树",{"0":{"51":1}}],["hashmap底层数据结构",{"0":{"48":1}}],["hashmap",{"0":{"52":1,"59":1,"63":1},"2":{"44":3,"45":1,"46":2,"56":2,"57":1,"58":1,"61":1,"63":2,"70":1,"72":3,"180":1}}],["hashset",{"0":{"44":1,"45":1,"46":1},"2":{"24":1,"44":4,"45":3,"46":2,"70":1,"127":5}}],["hash数据结构会使用hashtable作为底层实现",{"2":{"18":1}}],["hash数据结构会采用ziplist作为其底层实现",{"2":{"18":1}}],["hashtable或hashset中",{"2":{"128":1}}],["hashtable",{"2":{"18":1,"59":2}}],["hash的底层原理",{"0":{"18":1}}],["hash",{"0":{"21":1,"22":1},"2":{"13":1,"14":2,"15":1,"21":3,"22":4,"52":2,"55":1,"56":3,"57":2,"60":1,"133":1,"181":1}}],["有一个很大的区别就是",{"2":{"167":1}}],["有两种方式",{"2":{"147":1}}],["有以下两种情况finally不会被执行",{"2":{"143":1}}],["有何区别",{"0":{"134":1}}],["有什么用",{"0":{"126":1}}],["有什么区别",{"0":{"36":1,"76":1,"139":1},"1":{"77":1,"78":1}}],["有",{"2":{"112":1}}],["有符号整数",{"2":{"108":1}}],["有缓存会使用缓存",{"2":{"87":1}}],["有表结构",{"2":{"82":1}}],["有可能导致这个问题",{"2":{"58":1}}],["有点类似于",{"2":{"24":1}}],["有这两个特有的特性",{"2":{"14":1}}],["有序集合",{"2":{"13":1,"14":1,"15":1}}],["有减低了大量数据丢失的风险",{"2":{"11":1}}],["集合类",{"0":{"72":1}}],["集合框架基础",{"2":{"180":1}}],["集合框架位于",{"2":{"71":1}}],["集合框架常用工具类",{"0":{"71":1}}],["集合框架可以分为两条大的支线",{"2":{"70":1}}],["集合工具的内部类",{"2":{"59":1}}],["集合在被遍历期间如果内容发生变化",{"2":{"38":1}}],["集合中的元素没有先后顺序但都唯一",{"2":{"24":1}}],["集合中每个元素关联一个分数",{"2":{"14":1,"15":1}}],["集合",{"2":{"13":1,"14":1,"15":1}}],["集成了aof和rdb的优点",{"2":{"8":1}}],["哈希碰撞",{"2":{"129":1}}],["哈希寻址",{"2":{"52":1}}],["哈希",{"2":{"13":1,"14":1,"15":1}}],["分层开发",{"2":{"181":1}}],["分类标签",{"2":{"181":1}}],["分析",{"2":{"181":1}}],["分析器",{"2":{"84":2}}],["分组查询",{"2":{"181":1}}],["分支管理",{"2":{"181":1}}],["分割字符串",{"2":{"137":1}}],["分布式系统",{"2":{"90":1}}],["分布式锁",{"2":{"14":1}}],["分布式锁等场景",{"2":{"13":1}}],["分页操作造成了大量的碎片",{"2":{"80":1}}],["分别表示页中的最小记录和最大记录",{"2":{"79":1}}],["分别是jdk的动态代理",{"2":{"148":1}}],["分别是压缩列表",{"2":{"16":1}}],["分别是",{"2":{"10":1,"118":1}}],["兼容性差",{"2":{"11":1}}],["同一个字符串实例可以被多个线程共享",{"2":{"133":1}}],["同一时刻只有一个客户端能够成功地为一个key设定值",{"2":{"32":1}}],["同个类中的多个方法可以有相同的方法名称",{"2":{"96":1}}],["同步的静态⽅法",{"2":{"71":1}}],["同步将aof日志写回硬盘",{"2":{"9":1}}],["同时",{"2":{"166":1}}],["同时也会与其他已经加入的对象的",{"2":{"127":1}}],["同时也会为value创建一个新的redisobject",{"2":{"33":1}}],["同时也将一些sql注入攻击的",{"2":{"91":1}}],["同时主从同步也会丢失这一条数据",{"2":{"87":1}}],["同时记录redo",{"2":{"87":1}}],["同时结合",{"2":{"11":1}}],["可选",{"2":{"181":2}}],["可确保",{"2":{"167":1}}],["可变",{"2":{"131":1}}],["可变性",{"2":{"131":1}}],["可见性提升为public",{"2":{"124":1}}],["可用于在方法或构造方法中引用当前对象",{"2":{"108":1}}],["可用于调用父类的方法或者字段",{"2":{"108":1}}],["可防sql注入",{"2":{"91":1}}],["可行的方案是拷贝数据文件",{"2":{"76":1}}],["可移植性",{"2":{"76":1}}],["可重复的集合",{"2":{"70":1}}],["可视化开发环境",{"2":{"69":1}}],["可扩展性",{"2":{"69":1}}],["可能导致",{"2":{"58":1}}],["可能导致元素的丢失",{"2":{"58":1}}],["可能为",{"2":{"56":1}}],["可能需要对整个列表进行重写",{"2":{"16":1}}],["可能会导致不连续",{"2":{"90":1}}],["可能会涉及到数据的重新分配",{"2":{"90":1}}],["可能会发生这些问题",{"2":{"58":1}}],["可能会有空的内存空间",{"2":{"36":1}}],["可能会对",{"2":{"10":1}}],["可能会阻塞其他操作",{"2":{"9":1}}],["可以捕获到文本的语义特征",{"2":{"172":1}}],["可以解决大模型的知识时效性限制和幻觉问题",{"2":{"169":1}}],["可以不申明或不捕获",{"2":{"144":1}}],["可以不处理",{"2":{"139":1}}],["可以生成本地化信息",{"2":{"141":1}}],["可以catch或者throws",{"2":{"140":1}}],["可以通过",{"2":{"139":1}}],["可以通过索引直接查找到元素",{"2":{"72":1}}],["可以通过索引访问元素",{"2":{"45":1}}],["可以直接代理实现类",{"2":{"151":1}}],["可以直接返回缓存的引用",{"2":{"133":1}}],["可以直接通过数组下标获取",{"2":{"36":1}}],["可以重写equals方法",{"2":{"124":1}}],["可以重写tostring方法",{"2":{"124":1}}],["可以实现对浮点数的运算",{"2":{"121":1}}],["可以实现线程安全的",{"2":{"59":1}}],["可以看到",{"2":{"112":1}}],["可以看作是⼀个动态数组",{"2":{"72":1}}],["可以根据需要进",{"2":{"108":1}}],["可以根据参数的不同",{"2":{"101":1}}],["可以用",{"2":{"94":1}}],["可以采取以下措施",{"2":{"90":1}}],["可以分为两种",{"2":{"85":1}}],["可以继续拆分成更细致的部分",{"2":{"83":1}}],["可以帮助数据库管理员或开发者优化数据库的性能",{"2":{"78":1}}],["可以在运行时动态生成类的字节码",{"2":{"150":1}}],["可以在子类对方法进行重写",{"2":{"96":1}}],["可以在表的尾部插入新的数据",{"2":{"76":1}}],["可以在两端插⼊和删除元素的队列",{"2":{"73":1}}],["可以在需要时动态扩容数组的容量",{"2":{"72":1}}],["可以在多线程下并发使用",{"2":{"39":1}}],["可以从利用反射中可用的类型信息中受益",{"2":{"69":1}}],["可以有多个相同的元素",{"2":{"45":1}}],["可以有重复元素",{"2":{"15":1}}],["可以sleep一段时间",{"2":{"28":1}}],["可以使⽤用",{"2":{"117":1}}],["可以使用单引",{"2":{"108":1}}],["可以使用linkedhashmap",{"2":{"60":1}}],["可以使用blpop",{"2":{"28":1}}],["可以使用redis的incr",{"2":{"27":1}}],["可以使用日期",{"2":{"26":1}}],["可以使得数据更少的丢失",{"2":{"11":1}}],["可以组成一个",{"2":{"26":1}}],["可以获取部分字段的信息",{"2":{"21":1}}],["可以更快的启动",{"2":{"11":1}}],["才会加载后半部分的",{"2":{"11":1}}],["才会将命令记录到",{"2":{"9":1}}],["内连接",{"2":{"88":1}}],["内部结构是基于页的",{"2":{"167":1}}],["内部使用",{"2":{"131":1}}],["内部暴露",{"2":{"69":1}}],["内部定义了一个对象锁",{"2":{"59":1}}],["内存地址",{"2":{"124":1}}],["内存管理",{"2":{"107":1}}],["内存空间不连续",{"2":{"36":1}}],["内存占用",{"2":{"36":1}}],["内存",{"2":{"27":1}}],["内存受限的场景",{"2":{"16":1}}],["内存淘汰机制",{"2":{"13":1}}],["内存中的数据就会丢失",{"2":{"8":1}}],["内容生成的混合架构",{"2":{"169":1}}],["内容",{"2":{"11":2}}],["格式的内容",{"2":{"11":1}}],["格式的增量数据",{"2":{"11":1}}],["格式的全量数据",{"2":{"11":1}}],["格式的",{"2":{"11":1}}],["格式和",{"2":{"11":1}}],["写完redo",{"2":{"87":1}}],["写入失败",{"2":{"167":1}}],["写入到redo",{"2":{"166":1}}],["写入更新数据",{"2":{"87":1}}],["写入完成后通知主进程将新的含有",{"2":{"11":1}}],["写数据成本较高",{"2":{"80":1}}],["写时复制",{"2":{"9":1,"42":1}}],["方",{"2":{"108":1}}],["方法是比较的对象的内存地址",{"2":{"134":1}}],["方法是被重写过的",{"2":{"134":1}}],["方法判断是相等的两个对象",{"2":{"128":1}}],["方法判断两个对象是相等的",{"2":{"128":1,"129":1}}],["方法来检查",{"2":{"127":1}}],["方法或类是最终的",{"2":{"108":1}}],["方法实现",{"2":{"102":1}}],["方法名与形参列表必须一致",{"2":{"96":1}}],["方法重写",{"2":{"180":1}}],["方法重写时",{"2":{"96":1}}],["方法重载和重写的区别",{"0":{"96":1}}],["方法的话就可能会导致",{"2":{"128":1}}],["方法的重写描述的是父类和子类之间的",{"2":{"96":1}}],["方法的参数上的注解",{"2":{"68":1}}],["方法",{"2":{"68":1,"113":2,"124":2,"180":1,"181":1}}],["方法及属性的机制",{"2":{"67":1}}],["方法内通过对象锁实现",{"2":{"59":1}}],["方法做故障恢复时",{"2":{"10":1}}],["方式写入到",{"2":{"11":2}}],["提升查询效率",{"2":{"181":1}}],["提升写入性能",{"2":{"165":1}}],["提交实践",{"2":{"181":1}}],["提交redo",{"2":{"87":1}}],["提取",{"2":{"86":1}}],["提供更新",{"2":{"169":1}}],["提供额外的功能操作",{"2":{"146":1}}],["提供事务支持",{"2":{"76":1}}],["提供的一种在运行时动态获取和操作类",{"2":{"67":1}}],["提供的",{"2":{"19":1}}],["提供了⼀些对数组进⾏排序",{"2":{"71":1}}],["提供了⼀些对集合进⾏排序",{"2":{"71":1}}],["提供了两个常⽤的⼯具类",{"2":{"71":1}}],["提供了两个命令来生成",{"2":{"10":1}}],["提供了多种数据类型来支持不同的业务场景",{"2":{"13":1}}],["提出了混合使用",{"2":{"11":1}}],["001表示2",{"2":{"19":1}}],["01表示1",{"2":{"19":1}}],["0",{"0":{"178":1},"1":{"179":1,"180":1},"2":{"11":2,"14":1,"19":2,"26":2,"52":1,"55":1,"56":2,"57":1,"94":1,"122":1,"155":1}}],["404",{"2":{"181":1}}],["40",{"2":{"159":1}}],["40亿",{"2":{"20":1}}],["40亿的数如何排序",{"0":{"20":1}}],["46",{"2":{"108":1}}],["45",{"2":{"108":1}}],["44",{"2":{"108":1}}],["43",{"2":{"108":1}}],["42",{"2":{"108":1}}],["41",{"2":{"108":1}}],["4",{"0":{"178":1},"1":{"179":1,"180":1},"2":{"11":2,"36":1,"72":1,"87":1,"88":1,"108":1,"118":1,"122":1,"159":1,"170":1,"174":1,"181":1}}],["丢失的数据就会比较多",{"2":{"11":1}}],["丢失的数据会更多",{"2":{"10":1}}],["混合持久化缺点",{"2":{"11":1}}],["混合持久化结合了",{"2":{"11":1}}],["混合持久化优点",{"2":{"11":1}}],["混合持久化工作在",{"2":{"11":1}}],["混合持久化",{"0":{"11":1}}],["混合持久方式",{"2":{"8":1}}],["则记录一个相反的update操作",{"2":{"163":1}}],["则必须跟一个",{"2":{"142":1}}],["则该方法返回的信息与",{"2":{"141":1}}],["则创建此字符串并放入池中",{"2":{"135":1}}],["则返回其引用",{"2":{"135":1}}],["则返回行",{"2":{"88":1}}],["则",{"0":{"129":1}}],["则会查找不到",{"2":{"128":1}}],["则会抛出concurrent",{"2":{"38":1}}],["则需要查询对应的",{"2":{"89":1}}],["则需要把链表转换为红黑树",{"2":{"52":1}}],["则说明",{"2":{"89":1}}],["则直接插入即可否则需要覆盖",{"2":{"52":1}}],["则首先将当前容器复制一份",{"2":{"42":1}}],["则异常不会抛出",{"2":{"38":1}}],["则在bitmap的第6位",{"2":{"20":1}}],["则通过down指针下沉到下一层继续查找",{"2":{"17":1}}],["则继续在同一层级向右移动",{"2":{"17":1}}],["则被修改的数据会复制一份副本",{"2":{"10":1}}],["则主线程和",{"2":{"10":1}}],["服务器故障时",{"2":{"10":1}}],["服务器发生宕机了",{"2":{"9":1}}],["性能开销",{"2":{"69":1}}],["性能较高",{"2":{"42":1}}],["性能较低",{"2":{"16":1}}],["性能产生影响",{"2":{"10":1}}],["性能才会高",{"2":{"8":1}}],["都会从",{"2":{"167":1}}],["都会回收掉只被弱引用关联的对象",{"2":{"115":1}}],["都会检测modcount变量是否为expectedmodcount值",{"2":{"38":1}}],["都必须在类中定义",{"2":{"107":1}}],["都可以包含抽象方法",{"2":{"102":1}}],["都可以使用的命令",{"2":{"34":1}}],["都是用于比较两个对象是否相等",{"2":{"127":1}}],["都是通过",{"2":{"121":1}}],["都是对sql语句进行预编译处理注意",{"2":{"91":1}}],["都是把内存中的",{"2":{"10":1}}],["都记录到磁盘中",{"2":{"10":1}}],["次修改",{"2":{"10":3}}],["18",{"2":{"108":1}}],["17",{"2":{"108":1}}],["14",{"2":{"108":1}}],["1时当作一个整体",{"2":{"91":1}}],["16bit",{"2":{"117":2}}],["16",{"2":{"52":1,"55":1,"108":1}}],["127",{"2":{"108":1,"122":2}}],["128",{"2":{"108":1,"122":1}}],["12",{"2":{"27":1,"108":1}}],["12k",{"2":{"19":2}}],["1001",{"2":{"91":1}}],["10000",{"2":{"10":1}}],["10",{"2":{"10":1}}],["1",{"0":{"86":1,"149":1,"171":1},"2":{"10":1,"14":1,"19":2,"26":3,"27":4,"36":4,"41":1,"52":1,"56":7,"57":1,"58":5,"63":1,"72":1,"87":2,"88":1,"91":1,"94":1,"99":1,"108":3,"117":1,"118":1,"132":1,"136":1,"144":1,"147":1,"181":1}}],["900",{"2":{"10":1}}],["它用于在事务回滚或者数据库崩溃时撤销已提交的事务对数据库的修改",{"2":{"163":1}}],["它告诉代码只要是实现了serializable接口的类都是可以被序列化的",{"2":{"156":1}}],["它内部还有很多substring",{"2":{"133":1}}],["它是最弱的一种引用关系",{"2":{"115":1}}],["它主要包含两个部分",{"2":{"112":1}}],["它不支持c风格的隐式声明",{"2":{"109":1}}],["它通常用于与操作系统或其他本地库进行交互",{"2":{"108":1}}],["它通常用于处理大量的数据",{"2":{"108":1}}],["它采用表的形式来存储数据",{"2":{"82":1}}],["它基于非唯一索引",{"2":{"78":1}}],["它要求被锁定的列必须是主键或唯一索引列",{"2":{"78":1}}],["它会扫描所有的redo",{"2":{"166":1}}],["它会锁定整张表",{"2":{"77":1}}],["它会同时将这个写命令写入到",{"2":{"9":1}}],["它允许扩展编译时检查潜在类型不匹配问题的功能",{"2":{"109":1}}],["它允许多个事务同时对同一表的不同行进行操作",{"2":{"77":1}}],["它允许用户在保证原子性的前提下为一个key设置值",{"2":{"32":1}}],["它的执行流程如下",{"2":{"166":1}}],["它的主要作用是保证服务崩溃后",{"2":{"163":1}}],["它的对象才能被序列化",{"2":{"156":1}}],["它的值不需要维持",{"2":{"155":1}}],["它的值范围是",{"2":{"108":1}}],["它的上级",{"2":{"144":1}}],["它的元素按照⾃然顺序排序或者",{"2":{"73":1}}],["它的名字叫copyonwrite",{"2":{"42":1}}],["它将集合",{"2":{"65":1}}],["它又在二叉查找树的基础上增加了一些规则",{"2":{"49":1}}],["它们是什么",{"0":{"163":1}}],["它们在空间占用上都有一些额外的消耗",{"2":{"36":1}}],["它们的意思分别是",{"2":{"10":1}}],["它没有实现randmoaccess",{"2":{"36":1}}],["它也实现了randmoaccess",{"2":{"36":1}}],["它支持多种数据类型和原子操作",{"2":{"33":1}}],["实战课程",{"2":{"181":1}}],["实践建议",{"2":{"181":4}}],["实现序列化和反序列化为什么要实现",{"0":{"156":1}}],["实现类",{"2":{"151":1}}],["实现cloneable接口",{"2":{"124":1}}],["实现一次编写",{"2":{"112":1}}],["实现一个简单的抽奖系统的话",{"2":{"25":1}}],["实现一个排行榜怎么做",{"0":{"23":1}}],["实现跨平台的",{"2":{"110":1}}],["实现多态的三要素",{"2":{"101":1}}],["实现数据的存储和提取",{"2":{"84":1}}],["实现了对象中各个属性的复制",{"2":{"124":1}}],["实现了",{"2":{"73":2}}],["实现了数据持久化的机制",{"2":{"8":1}}],["实现的",{"2":{"44":2,"45":1}}],["实现抽奖系统怎么做",{"0":{"25":1}}],["实现",{"0":{"40":1},"2":{"19":1,"112":3,"180":1,"181":1}}],["实际上执行的是",{"2":{"10":1}}],["别看选项名叫",{"2":{"10":1}}],["还有更极端的情况",{"2":{"143":1}}],["还有一个通用的日志模块",{"2":{"84":1}}],["还可以声明类",{"2":{"108":1}}],["还可以通过配置文件的选项来实现每隔一段时间自动执行一次",{"2":{"10":1}}],["还是",{"0":{"21":1,"22":1}}],["还是会阻塞后续的操作无法执行",{"2":{"9":1}}],["还支持事务",{"2":{"13":1}}],["主从复制以及数据备份",{"2":{"165":1}}],["主从复制模式",{"2":{"13":1}}],["主动抛出异常",{"2":{"108":1}}],["主",{"2":{"104":1}}],["主要目的是为了避免字符串的重复创建",{"2":{"135":1}}],["主要有以下几点原因",{"2":{"133":1}}],["主要分为两步",{"2":{"84":1}}],["主要包括连接器",{"2":{"84":1}}],["主要用于系统崩溃后的恢复",{"2":{"165":1}}],["主要用于系统崩溃后的恢复和保证事务的持久性",{"2":{"164":1}}],["主要用于防止其他事务插入到这个范围内",{"2":{"78":1}}],["主要用于存储地理位置信息",{"2":{"19":1}}],["主要由",{"2":{"70":1}}],["主要⽤于去重",{"2":{"44":1}}],["主要需要用到下面这两个命令",{"2":{"27":1}}],["主线程处理的操作命令",{"2":{"11":1}}],["主线程仍然可以直接修改原来的数据",{"2":{"10":1}}],["主线程",{"2":{"10":1}}],["主进程就可以继续像往常一样处理命令了",{"2":{"9":1}}],["主进程就会创建重写",{"2":{"9":1}}],["主进程收到该信号后",{"2":{"9":1}}],["主进程依然可以正常处理命令",{"2":{"9":1}}],["主进程可以继续处理命令请求",{"2":{"9":1}}],["因此称为",{"2":{"159":1}}],["因此如果某个类被标记为final",{"2":{"150":1}}],["因此将创建总共",{"2":{"136":1}}],["因此value数组不能改变",{"2":{"132":1}}],["因此value不可以指向其他对象",{"2":{"132":1}}],["因此是线程安全的",{"2":{"131":1}}],["因此通常执行更快",{"2":{"107":1}}],["因此会导致不连续",{"2":{"90":1}}],["因此每次新纪录都要被插到现有索引页得中间某个位置",{"2":{"80":1}}],["因此当平台发生改变的时候",{"2":{"69":1}}],["因此适⽤于需要⼤量范围查找或者有序遍历的场景",{"2":{"63":1}}],["因此",{"2":{"38":1,"58":1,"69":1,"110":1}}],["因此不需要移动元",{"2":{"36":1}}],["因此读写速度非常快",{"2":{"13":1}}],["因此在",{"2":{"10":1}}],["因为是循环写",{"2":{"167":1}}],["因为是链表结构",{"2":{"36":1}}],["因为序列化是针对对象而言的",{"2":{"157":1}}],["因为string的hash值经常会使用到",{"2":{"133":1}}],["因为字符串不可变",{"2":{"133":1}}],["因为两个相等的对象的",{"2":{"128":1}}],["因为集合的容器要求元素是",{"2":{"118":1}}],["因为编译的结果不是机器码",{"2":{"110":1}}],["因为java代码在运行时需要通过jvm转换为机器码",{"2":{"107":1}}],["因为一次只有一个事务可以写入或修改表",{"2":{"77":1}}],["因为它涉及更多底层的概念和复杂性",{"2":{"107":1}}],["因为它允许更高的并行度",{"2":{"77":1}}],["因为它是⽤",{"2":{"44":1}}],["因为元素个数超出",{"2":{"58":1}}],["因为需要遍历链表找到插⼊位置",{"2":{"36":1}}],["因为压缩列表是一块连续的内存区域",{"2":{"16":1,"18":1}}],["因为执行命令由单线程负责的",{"2":{"13":1}}],["因为创建子进程的时候",{"2":{"10":1}}],["因为直接将",{"2":{"10":1}}],["因为",{"2":{"10":1,"27":1,"41":1,"83":1,"111":1}}],["因为如果是使用线程",{"2":{"9":1}}],["因为如果先将写操作命令记录到",{"2":{"9":1}}],["因为当写操作命令执行成功后",{"2":{"9":1}}],["所储存的值的类型",{"2":{"34":1}}],["所有输出流的基类",{"2":{"159":1}}],["所有类可见",{"2":{"108":1}}],["所有跨存储引擎的功能都在这一层实现",{"2":{"84":1}}],["所有的输入流的基类",{"2":{"159":1}}],["所有的异常都有一个共同的祖先",{"2":{"139":1}}],["所有的java程序会首先被编译为",{"2":{"112":1}}],["所有的存储引擎中只有",{"2":{"75":1}}],["所有的叶子节点都是是黑色的",{"2":{"49":1}}],["所有的⽅法都使",{"2":{"41":1}}],["所有的key和value都按顺序存储",{"2":{"16":1,"18":1}}],["所有数据",{"2":{"10":1}}],["所谓的快照",{"2":{"10":1}}],["所以有字符流",{"2":{"160":1}}],["所以我们通过字节流读取文件的时候一般都是逐个字节转换就会导致乱码",{"2":{"160":1}}],["所以实体类使用克隆的前提是",{"2":{"124":1}}],["所以就会导致小数精度发生损失的情况",{"2":{"120":1}}],["所以没有包含任何开发工具",{"2":{"112":1}}],["所以对引用对象进行操作会同时改变原对象",{"2":{"106":1}}],["所以你可以看到一个类中有多个构造函数的情况",{"2":{"97":1}}],["所以也可以当做双端队列来使⽤",{"2":{"73":1}}],["所以使用反射可能会导致意料之外的副作用",{"2":{"69":1}}],["所以平衡二叉树插入和删除的效率比红黑树要低",{"2":{"51":1}}],["所以单线程环境下效率较低",{"2":{"41":1}}],["所以不会被序列化",{"2":{"157":1}}],["所以不会触发concurrent",{"2":{"39":1}}],["所以不会阻塞当前命令的执行",{"2":{"9":1}}],["所以在跨平台的数据转移中会很方便",{"2":{"76":1}}],["所以在遍历过程中对原集合所作的修改并不能被迭代器检测到",{"2":{"39":1}}],["所以在插入时候",{"2":{"37":1}}],["所以每个节点会占用更多的空间",{"2":{"36":1}}],["所以它没法根据序号直接获取元素",{"2":{"36":1}}],["所以它可以根据下标查找",{"2":{"36":1}}],["所以执行快照是一个比较重的操作",{"2":{"10":1}}],["所以如果写入",{"2":{"10":1}}],["所以用",{"2":{"10":1}}],["所以当",{"2":{"9":1}}],["所以",{"2":{"8":1,"10":1,"19":1,"26":1,"27":1,"46":1,"69":1,"132":1}}],["势必会造成",{"2":{"10":1}}],["一",{"0":{"178":1,"179":1},"1":{"179":1,"180":2},"2":{"181":4}}],["一般会选择线程终止",{"2":{"139":1}}],["一般情况下",{"2":{"111":1}}],["一般用于传入数据库对象",{"2":{"91":1}}],["一次编写",{"2":{"109":1}}],["一根绳子可以不系气球",{"2":{"94":1}}],["一种是更新",{"2":{"85":1}}],["一种是查询",{"2":{"85":1}}],["一是表必须有一个主键",{"2":{"83":1}}],["一对多",{"2":{"82":1}}],["一对一",{"2":{"82":1}}],["一个是追加写",{"2":{"167":1}}],["一个是循环写",{"2":{"167":1}}],["一个访问权限修饰符",{"2":{"108":3}}],["一个类只有实现了serializable接口",{"2":{"156":1}}],["一个类可以实现多个接口",{"2":{"102":1}}],["一个类浏览器需要可以枚举类的成员",{"2":{"69":1}}],["一个对象序列化的接口",{"2":{"156":1}}],["一个对象是否有虚引用存在",{"2":{"115":1}}],["一个对象可以有",{"2":{"94":1}}],["一个对象引用可以指向",{"2":{"94":1}}],["一个数据页大致划分七个部分",{"2":{"79":1}}],["一个",{"2":{"68":1}}],["一旦",{"2":{"10":1}}],["一位在校大学生",{"0":{"1":1}}],["使每个属性都直接依赖于主键",{"2":{"83":1}}],["使用赋值操作是无法达到目的的",{"2":{"124":1}}],["使用class",{"2":{"113":1}}],["使用反射",{"2":{"113":1}}],["使用反射技术要求程序必须在一个没有安全限制的环境中运行",{"2":{"69":1}}],["使用try",{"2":{"109":1}}],["使用全局唯一",{"2":{"90":1}}],["使用最广泛",{"2":{"75":1}}],["使用尾插法插入元素",{"2":{"58":1}}],["使用头插法插入元素",{"2":{"58":1}}],["使用扰动函数",{"2":{"54":1}}],["使用sortedset",{"2":{"29":1}}],["使用list类型保存数据信息",{"2":{"28":1}}],["使用redis提供的hash",{"2":{"27":1}}],["使用distinct",{"2":{"27":1}}],["使用",{"0":{"23":1,"25":1,"26":1,"27":1},"2":{"27":1,"40":3,"90":1,"141":1,"172":1}}],["使用bitmap进行排序是一种特殊的方法",{"2":{"20":1}}],["使用了混合持久化",{"2":{"11":1}}],["使得它具有了对象的性质",{"2":{"118":1}}],["使得不同存储引擎能够与server层无缝对接",{"2":{"84":1}}],["使得在锁持有期间",{"2":{"77":1}}],["使得",{"2":{"11":2}}],["使得新旧两个",{"2":{"9":1}}],["使的aof文件体积变小了",{"2":{"9":1}}],["该范围内的所有浮点数计算将遵循",{"2":{"108":1}}],["该命令用于在",{"2":{"34":1}}],["该结构包含类型信息和指向底层简单动态字符串",{"2":{"33":1}}],["该函数主要做以下工作",{"2":{"9":1}}],["该错误的命令记录到",{"2":{"9":1}}],["扫描数据库中所有数据",{"2":{"9":1}}],["和非运行时异常",{"0":{"140":1}}],["和舍入行为",{"2":{"108":1}}],["和排它锁",{"2":{"78":1}}],["和封装了链表的",{"2":{"70":1}}],["和跳跃表",{"2":{"16":1}}],["和",{"0":{"36":1,"41":1,"45":1,"63":1,"76":1,"131":1,"134":1,"139":1},"1":{"77":1,"78":1},"2":{"9":1,"10":1,"11":1,"19":2,"26":2,"45":1,"58":3,"61":1,"70":1,"71":1,"83":1,"108":2,"112":1,"127":1,"131":1,"139":1,"163":2,"167":2}}],["当数据库",{"2":{"167":1}}],["当redo",{"2":{"166":1}}],["当系统发生故障时",{"2":{"166":1}}],["当事务提交时",{"2":{"166":1}}],["当一个事务开始时",{"2":{"166":1}}],["当一页写满",{"2":{"80":1}}],["当对象存储时",{"2":{"155":1}}],["当对象和它所引用的对象一起拷贝时即发生深拷贝",{"2":{"104":1}}],["当需要持久化",{"2":{"153":1}}],["当需要代理多个类的时候",{"2":{"147":1}}],["当接口需要增加",{"2":{"147":1}}],["当在",{"2":{"142":1}}],["当比较对象的数量很大的时候能提升效率",{"2":{"129":1}}],["当用其中的一个对象作为键保存到hashmap",{"2":{"128":1}}],["当你把对象加入",{"2":{"127":1}}],["当你在类",{"2":{"108":1}}],["当垃圾收集器工作时",{"2":{"115":1}}],["当遇到",{"2":{"108":1}}],["当父类的功能无法满足子类的需求",{"2":{"96":1}}],["当再传入",{"2":{"91":1}}],["当删除某条记录时",{"2":{"90":1}}],["当插入数据时",{"2":{"90":1}}],["当客户端连接",{"2":{"84":1}}],["当使用范围条件查询时",{"2":{"78":1}}],["当前默认的存储引擎是",{"2":{"75":1}}],["当前节点是否为树节点",{"2":{"54":1}}],["当前节点和key匹配",{"2":{"54":1}}],["当键值对数量超过阈值",{"2":{"57":1}}],["当然",{"2":{"36":2}}],["当执行setex命令时",{"2":{"33":1}}],["当lpop没有消息时",{"2":{"28":1}}],["当不满足ziplist的条件时",{"2":{"18":1}}],["当满足特定条件时",{"2":{"18":1}}],["当查找一个元素时",{"2":{"17":1}}],["当zset的元素个数小于128个且每个元素的长度小于64字节时",{"2":{"16":1}}],["当开启了混合持久化时",{"2":{"11":1}}],["当子进程完成",{"2":{"9":1}}],["当",{"2":{"9":1}}],["期间",{"2":{"9":1,"11":1}}],["为练习项目创建",{"2":{"181":1}}],["为例子来说明为什么要有",{"2":{"127":1}}],["为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知",{"2":{"115":1}}],["为机器代码后再执行",{"2":{"111":1}}],["为1的记录",{"2":{"87":1}}],["为各种框架提供开箱即用的功能提供了便利",{"2":{"69":1}}],["为数组的⼤⼩",{"2":{"56":1}}],["为什么",{"0":{"167":1}}],["为什么string要设计成不可变的",{"0":{"133":1}}],["为什么不可变",{"0":{"132":1},"1":{"133":1}}],["为什么不用二叉树",{"0":{"51":1}}],["为什么重写",{"0":{"128":1}}],["为什么要有",{"0":{"127":1}}],["为什么要用自增",{"0":{"80":1}}],["为什么会出现这个问题呢",{"2":{"120":1}}],["为什么浮点数运算的时候会有精度丢失的风险",{"0":{"120":1},"1":{"121":1}}],["为什么需要包装类",{"0":{"118":1}}],["为什么说",{"0":{"111":1}}],["为什么记录完redo",{"2":{"87":1}}],["为什么你通过一个",{"2":{"68":1}}],["为什么你使用",{"2":{"68":1}}],["为什么hashmap的容量是2的幂次方",{"0":{"56":1}}],["为什么先执行命令再把数据写入日志呢",{"2":{"9":1}}],["为5",{"2":{"27":1}}],["为",{"2":{"22":2,"26":1,"58":1}}],["为了提升性能和减少内存消耗针对字符串",{"2":{"135":1}}],["为了让基本类型也具有对象的特征",{"2":{"118":1}}],["为了避免自增",{"2":{"90":1}}],["为了快速定位元素在底层数组中的下标",{"2":{"56":1}}],["为了降低哈希碰撞的概率",{"2":{"55":1}}],["为了保持保持平衡",{"2":{"51":1}}],["为了保持平衡",{"2":{"49":1}}],["为了集成了两者的优点",{"2":{"11":1}}],["为了解决这个问题",{"2":{"10":1}}],["为了解决这种数据不一致问题",{"2":{"9":1}}],["不具备",{"2":{"167":1}}],["不一样",{"2":{"167":1}}],["不一定",{"2":{"143":1}}],["不包括查询语句",{"2":{"165":1}}],["不包含具体的实现代码",{"2":{"102":1}}],["不管事务是否提交都会记录下来",{"2":{"163":1}}],["不管是文件读写还是网络发送接收",{"2":{"160":1}}],["不易维护",{"2":{"147":1}}],["不然编译报错",{"2":{"144":1}}],["不然编译不通过",{"2":{"140":1}}],["不受检查异常",{"2":{"139":1}}],["不是线程安全的",{"2":{"131":1}}],["不是实际的数据",{"2":{"10":1}}],["不可变的特性使得",{"2":{"133":1}}],["不可变",{"2":{"131":2}}],["不可重复的集合",{"2":{"70":1}}],["不用单独安装jre",{"2":{"112":1}}],["不同平台下编译生成的字节码是一样的",{"2":{"110":1}}],["不同的平台有不同的版本",{"2":{"110":1}}],["不同的存储引擎如innodb",{"2":{"84":1}}],["不同点",{"2":{"102":1}}],["不允许外部程序直接访问",{"2":{"99":1}}],["不允许重复元素",{"2":{"45":1}}],["不连续的问题",{"2":{"90":1}}],["不连续的原因可能有以下几点",{"2":{"90":1}}],["不连续",{"0":{"90":1},"2":{"90":1}}],["不匹配的返回null",{"2":{"88":2}}],["不直接提交",{"2":{"87":1}}],["不容易保证有序插入",{"2":{"80":1}}],["不涉及挪动记录",{"2":{"80":1}}],["不提供事务支持",{"2":{"76":1}}],["不过",{"2":{"69":2}}],["不过这个共享的内存只能以只读的方式",{"2":{"9":1}}],["不会造成精度丢失",{"2":{"121":1}}],["不会回退",{"2":{"90":1}}],["不会出现环形链表的问题",{"2":{"58":1}}],["不会阻塞当前写操作命令的执行",{"2":{"9":1}}],["不相等",{"2":{"53":1}}],["不保证元素的顺序",{"2":{"45":1}}],["不推荐",{"2":{"40":1}}],["不需要必须实现接口",{"2":{"151":1}}],["不需要自己编写",{"2":{"149":1}}],["不需要重新计算",{"2":{"133":1}}],["不需要移动元素",{"2":{"36":1}}],["不需要像",{"2":{"10":1}}],["不存在时设置",{"2":{"31":1}}],["不存在并发竞争的问题",{"2":{"13":1}}],["不重复元素",{"2":{"27":1}}],["不能改变对象内的成员变量",{"2":{"132":1}}],["不能改变状态的意思是",{"2":{"132":1}}],["不能再改变它的状态",{"2":{"132":1}}],["不能被修改或继承",{"2":{"108":1}}],["不能定义普通成员变量",{"2":{"102":1}}],["不能防止sql注入",{"2":{"91":1}}],["不能存在传递依赖",{"2":{"83":1}}],["不能在多线程下发生并发修改",{"2":{"38":1}}],["不能依赖于这个异常是否抛出而进行并发操作的编程",{"2":{"38":1}}],["不能像集合那样",{"2":{"27":1}}],["不能以消费组形式消费数据",{"2":{"14":1}}],["而手动去根据不同编码去拼接则不方便",{"2":{"160":1}}],["而字符流是为了应对汉字出现的情况",{"2":{"160":1}}],["而根据数据的处理方式又分为字节流和字符流",{"2":{"159":1}}],["而动态代理是在运行时动态生成类字节码",{"2":{"151":1}}],["而动态代理的实现也依赖反射",{"2":{"68":1}}],["而throw的话",{"2":{"144":1}}],["而throw只能一个",{"2":{"144":1}}],["而throw用于方法内部",{"2":{"144":1}}],["而且有字节缓冲流",{"2":{"160":1}}],["而且也没有实现serializable接口的话",{"2":{"156":1}}],["而且没有侵入原代码",{"2":{"147":1}}],["而且string没有对外提供修改内部状态的方法",{"2":{"132":1}}],["而且计算机在表示一个数字时",{"2":{"120":1}}],["而实现这种特性的正是java虚拟机jvm",{"2":{"109":1}}],["而在自动拆箱的过程中",{"2":{"119":1}}],["而在",{"2":{"108":1}}],["而在跳表中",{"2":{"17":1}}],["而java设计上避免了这些可能导致混淆和错误的特性",{"2":{"107":1}}],["而c++既支持面向过程编程",{"2":{"107":1}}],["而所有的对其他对象的引用仍然指向原来的对象",{"2":{"104":1}}],["而非抽象方法有具体的实现代码",{"2":{"102":1}}],["而非繁琐的循环",{"2":{"65":1}}],["而抽象类可以有静态代码块和静态方法",{"2":{"102":1}}],["而抽象类可以有构造函数",{"2":{"102":1}}],["而抽象类可以包含抽象方法和非抽象方法",{"2":{"102":1}}],["而抽象类可以定义各种类型的成员变量",{"2":{"102":1}}],["而抽象类使用abstract关键字进行声明",{"2":{"102":1}}],["而server层通过api调用这些功能",{"2":{"84":1}}],["而院校地址和电话又依赖于所在院校",{"2":{"83":1}}],["而有业务逻辑的字段做主键",{"2":{"80":1}}],["而表级锁在操作少量数据时更为高效",{"2":{"77":1}}],["而innodb在特定情况下也会使用表级锁",{"2":{"77":1}}],["而innodb支持",{"2":{"76":1}}],["而innodb",{"2":{"76":2}}],["而导致",{"2":{"58":1}}],["而是经过虚拟机间接与操作系统交互",{"2":{"112":1}}],["而是通过该类的方法实现对隐藏信息的操作和访问",{"2":{"99":1}}],["而是先进入准备状态",{"2":{"87":1}}],["而是先复制原有集合内容",{"2":{"39":1}}],["而是拷贝到了内核缓冲区",{"2":{"9":2}}],["而不复制它所引用的对象",{"2":{"104":1}}],["而不能只依赖于主键的一部分",{"2":{"83":1}}],["而不是开发java程序的话",{"2":{"112":1}}],["而不是自增",{"2":{"90":1}}],["而不是仅依赖于其中之一",{"2":{"83":1}}],["而不是范围查询",{"2":{"78":1}}],["而不是实际的数据",{"2":{"10":1}}],["而不会储存输入元素本身",{"2":{"27":1}}],["而跳跃表适合于数据量大",{"2":{"16":1}}],["而",{"2":{"10":1,"157":1,"167":1}}],["而当父子进程任意一方修改了该共享内存",{"2":{"9":1}}],["而使用子进程",{"2":{"9":1}}],["而这样就会降低性能",{"2":{"9":1}}],["xml",{"2":{"181":4}}],["x548c",{"2":{"89":1}}],["x锁",{"2":{"78":1}}],["x8fd9",{"2":{"77":1}}],["x6709",{"2":{"75":1}}],["x20",{"0":{"42":1,"62":1},"2":{"9":1,"45":2,"56":2,"57":1,"63":2,"71":2,"72":4,"75":1,"89":2}}],["x3c",{"2":{"2":8}}],["zh",{"2":{"181":1}}],["zrevrank",{"2":{"23":1}}],["zrevrange",{"2":{"23":1}}],["zrange",{"2":{"23":1}}],["ziplist和hashtable",{"2":{"18":1}}],["ziplist",{"2":{"16":1,"18":1}}],["zset的底层原理",{"0":{"16":1},"1":{"17":1}}],["zset",{"2":{"13":1,"14":2,"15":1,"16":1}}],["z",{"2":{"9":1}}],["的能力",{"0":{"167":1},"2":{"167":1}}],["的redo",{"2":{"166":1}}],["的执行流程",{"0":{"166":1}}],["的过程即输出",{"2":{"159":1}}],["的过期时间设为",{"2":{"31":1}}],["的访问",{"2":{"146":1}}],["的子类覆盖这个方法",{"2":{"141":1}}],["的子进程",{"2":{"9":1}}],["的引用",{"2":{"136":1}}],["的键",{"2":{"133":1}}],["的键是唯⼀的",{"2":{"44":1}}],["的比较",{"2":{"129":1}}],["的次数",{"2":{"127":1}}],["的作用是获取哈希码",{"2":{"126":1}}],["的运行时类",{"2":{"124":1}}],["的相应类型的缓存数据",{"2":{"122":1}}],["的系统上都可以运行不变",{"2":{"107":1}}],["的基础上增加了⼀个双向链表来保持键值对的插⼊顺序",{"2":{"72":1}}],["的基础上维护了⼀个双向链表",{"2":{"61":1}}],["的实现也用到了反射",{"2":{"68":1}}],["的查找效率是",{"2":{"63":2}}],["的⽐较器来判断元素应该插⼊到左⼦树还是右⼦树",{"2":{"63":1}}],["的⽐较器来决定元素的顺序",{"2":{"62":1}}],["的哈希值",{"2":{"63":1}}],["的哈希表中",{"2":{"57":1}}],["的最后⼀位",{"2":{"56":1}}],["的hashcode",{"2":{"55":1}}],["的时候",{"2":{"53":1,"68":1,"154":1}}],["的时候会发生什么",{"0":{"53":1}}],["的时间复杂度进行元素查找",{"2":{"16":1}}],["的底层是红⿊树",{"2":{"62":1}}],["的底层逻辑",{"2":{"46":1}}],["的底层实现",{"0":{"44":1}}],["的区别",{"0":{"41":1,"45":1,"63":1,"140":1}}],["的读写",{"2":{"40":1}}],["的读写操作都是在内存中",{"2":{"8":1}}],["的",{"0":{"52":1},"2":{"34":1,"46":2,"134":1}}],["的指针",{"2":{"33":1}}],["的值",{"2":{"31":1,"56":1}}],["的唯一计数",{"2":{"27":1}}],["的常见应用场景如下",{"2":{"24":1}}],["的应用场景是什么",{"0":{"24":1}}],["的数据到内存时",{"2":{"167":1}}],["的数据结构",{"2":{"73":2}}],["的数据类型经常被用在各种排行榜的场景",{"2":{"23":1}}],["的数组",{"2":{"19":1,"26":1}}],["的一半",{"2":{"21":1}}],["的空间",{"2":{"19":1}}],["的空间就能存储接近2^64个不同元素",{"2":{"19":1}}],["的存储结构做了优化",{"2":{"19":1}}],["的优点是",{"2":{"27":1}}],["的优点",{"2":{"11":1}}],["的格式",{"2":{"11":1}}],["的内容后",{"2":{"11":1}}],["的快照是全量快照",{"2":{"10":1}}],["的恢复操作缓慢",{"2":{"10":1}}],["的文件进行改名",{"2":{"9":1}}],["的文件中",{"2":{"9":1}}],["的重写",{"2":{"9":1}}],["等基础",{"2":{"181":1}}],["等类型放进去的",{"2":{"118":1}}],["等列",{"2":{"83":1}}],["等等框架中都大量使用了反射机制",{"2":{"68":1}}],["等等",{"2":{"24":1,"111":2}}],["等",{"2":{"14":1,"90":1,"124":1,"139":1,"180":1}}],["等到全部记录完后",{"2":{"9":1}}],["等待内核将数据写入硬盘",{"2":{"9":2}}],["重构项目",{"2":{"181":1}}],["重做日志缓冲区",{"2":{"166":1}}],["重做日志",{"2":{"163":1,"166":1}}],["重载",{"2":{"97":1,"180":1}}],["重载是面向对象的一个基本特性",{"2":{"96":1}}],["重复了是否",{"0":{"46":1}}],["重写的话一般按照属性是否相等去比较",{"2":{"125":1}}],["重写日志时",{"2":{"11":1}}],["重写工作",{"2":{"9":1}}],["重写缓冲区里的增量命令会以",{"2":{"11":1}}],["重写缓冲区中的所有内容追加到新的",{"2":{"9":1}}],["重写缓冲区",{"2":{"9":2}}],["重写",{"2":{"9":2,"97":1,"101":1}}],["重写子进程只会对这个内存进行只读",{"2":{"9":1}}],["重写期间",{"2":{"9":1}}],["重写aof的过程是怎样的",{"2":{"9":1}}],["重写后就会将新的aof文件覆盖掉原有的aof文件",{"2":{"9":1}}],["重写机制是在重写时",{"2":{"9":1}}],["重启",{"2":{"11":1}}],["重启速度",{"2":{"11":1}}],["重启时",{"2":{"9":1}}],["重启就能够从磁盘中恢复原有的数据",{"2":{"8":1}}],["重启后",{"2":{"8":1}}],["后端接口",{"2":{"181":1}}],["后端开发工程师零基础入门学习路线",{"0":{"177":1},"1":{"178":1,"179":1,"180":1,"181":1}}],["后者是字符输出流",{"2":{"159":1}}],["后者是字符输入流",{"2":{"159":1}}],["后解释两个步骤",{"2":{"111":1}}],["后的条件",{"2":{"91":1}}],["后续进行机器备份的时候",{"2":{"87":1}}],["后置节点和插⼊节点的引⽤",{"2":{"36":1}}],["后继节点和插入节点的指向就行了",{"2":{"36":1}}],["后台子进程重写",{"2":{"11":1}}],["后半部分是",{"2":{"11":1}}],["后",{"2":{"9":2,"167":1}}],["再以另一个对象作为键值去查找他们的时候",{"2":{"128":1}}],["再把class文件打成java包",{"2":{"109":1}}],["再插入",{"2":{"37":1}}],["再将命令记录到重写日志",{"2":{"9":2}}],["再由操作系统决定何时将缓冲区内容写回硬盘",{"2":{"9":1}}],["再执行该命令的话",{"2":{"9":1}}],["也称编译时增强",{"2":{"147":1}}],["也称为散列码",{"2":{"126":1}}],["也要申明抛出异常或者捕获",{"2":{"144":1}}],["也无法通过虚引用来取得一个对象实例",{"2":{"115":1}}],["也有windows",{"2":{"112":1}}],["也具有解释型语言的特征",{"2":{"111":1}}],["也支持面向对象编程",{"2":{"107":1}}],["也会被跳过",{"2":{"90":1}}],["也会带来一些风险",{"2":{"9":1}}],["也成功",{"2":{"89":1}}],["也不会触发叶子节点的分裂",{"2":{"80":1}}],["也实现了",{"2":{"73":1}}],["也增加了安全问题",{"2":{"69":1}}],["也可以系一个气球",{"2":{"94":1}}],["也可以修改或者添加部分字段",{"2":{"21":1}}],["也可能为",{"2":{"56":1}}],["也就保证了",{"2":{"56":1}}],["也就是bufferedoutputstream",{"2":{"160":1}}],["也就是被private修饰",{"2":{"132":1}}],["也就是jdk中已经集成了",{"2":{"112":1}}],["也就是各个槽对应的记录在页面中的地址偏移量",{"2":{"79":1}}],["也就是容量",{"2":{"57":1}}],["也就是",{"2":{"56":1}}],["也就是散列函数",{"2":{"48":1}}],["也就是说被transient修饰的成员变量",{"2":{"155":1}}],["也就是说如果",{"2":{"128":1}}],["也就是说class文件并不直接与机器的操作系统交互",{"2":{"112":1}}],["也就是说一个子类只有一个父类",{"2":{"100":1}}],["也就是说只",{"2":{"75":1}}],["也就是说平衡二叉树保持平衡的效率更低",{"2":{"51":1}}],["也就是说",{"2":{"11":1,"91":1,"166":1,"167":1}}],["也就是说每次执行快照",{"2":{"10":1}}],["也就是数据是能被修改的",{"2":{"10":1}}],["也就是会创建子进程来生成",{"2":{"10":1}}],["也就是每次写操作命令执行完后",{"2":{"9":1}}],["也叫散列",{"2":{"15":1}}],["也叫混合持久化",{"2":{"11":1}}],["el",{"2":{"181":1}}],["else",{"2":{"180":1}}],["element",{"2":{"36":1}}],["element2",{"2":{"27":1}}],["element1",{"2":{"27":1}}],["eclipse",{"2":{"180":1}}],["embedding",{"2":{"172":1}}],["error",{"0":{"139":1},"2":{"139":2}}],["environment",{"2":{"112":1}}],["enum",{"2":{"108":1}}],["equals和引用相等==的区别",{"0":{"125":1}}],["equals",{"0":{"53":1,"128":1,"129":1,"134":2},"2":{"45":1,"53":2,"124":2,"125":1,"127":3,"128":3,"129":1,"134":2,"137":1}}],["e",{"2":{"36":1,"57":2}}],["explain",{"2":{"181":1}}],["export",{"2":{"174":1}}],["extends",{"2":{"180":1}}],["extensions",{"2":{"173":1,"176":1}}],["extension",{"0":{"173":1},"1":{"174":1,"175":1,"176":1}}],["exception由具体的环境",{"2":{"140":1}}],["exception包括runtimeexception和error类",{"2":{"140":1}}],["exception",{"0":{"139":1},"2":{"38":1,"39":2,"139":4}}],["exists",{"2":{"32":1,"34":1}}],["examples",{"0":{"2":1,"173":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1,"174":1,"175":1,"176":1}}],["everyse",{"2":{"9":1}}],["每月活跃用户",{"2":{"181":1}}],["每当有数据被修改",{"2":{"166":1}}],["每当迭代器使用hashnext",{"2":{"38":1}}],["每次更新操作完成后",{"2":{"167":1}}],["每次插入新的记录就会顺序添加到当前索引节点的后续位置",{"2":{"80":1}}],["每次都是追加操作",{"2":{"80":1}}],["每次写操作命令执行完后",{"2":{"9":2}}],["每个目标对象对应一个代理类",{"2":{"147":1}}],["每个占多少位",{"0":{"117":1}}],["每个节点都⼤于其左⼦树中的任何节点",{"2":{"62":1}}],["每个节点要么是红色",{"2":{"49":1}}],["每个红色节点的两个子节点一定都是黑色",{"2":{"49":1}}],["每个key都与一个redisobject结构相关联",{"2":{"33":1}}],["每个",{"2":{"27":1,"108":1}}],["每个键值对都以字典的形式保存",{"2":{"18":1}}],["每下降一层",{"2":{"17":1}}],["每执行一条写操作命令",{"2":{"8":1}}],["由这个代理类实现多个接口",{"2":{"147":1}}],["由虚拟机将程序解释给本地系统执行",{"2":{"112":1}}],["由",{"2":{"111":1}}],["由于代理对象要实现与目标对象一致的接口",{"2":{"147":1}}],["由于",{"2":{"108":1}}],["由于java简化了内存管理和垃圾回收机制",{"2":{"107":1}}],["由于每次插入主键的值近似于随机",{"2":{"80":1}}],["由于反射允许代码执行一些在正常情况下不被允许的操作",{"2":{"69":1}}],["由于迭代时是对原集合的拷贝进行遍历",{"2":{"39":1}}],["由于购物车中的商品频繁修改和变动",{"2":{"22":1}}],["由于数值范围是0",{"2":{"20":1}}],["由于前半部分是",{"2":{"11":1}}],["由于和执行操作命令在同一个线程",{"2":{"10":1}}],["由于写操作命令执行成功后才记录到",{"2":{"9":1}}],["由内核决定",{"2":{"9":2}}],["将之前的",{"2":{"181":1}}],["将生成的向量和对应文本存入向量数据库",{"2":{"172":1}}],["将长文档分割成适当大小的片段",{"2":{"171":1}}],["将对象从缓存数据库中读取出来需要反序列化",{"2":{"154":1}}],["将对象从文件中读取出来需要进行反序列化",{"2":{"154":1}}],["将对象存储到内存之前需要进行序列化",{"2":{"154":1}}],["将对象存储到数据库",{"2":{"154":1}}],["将对象存储到文件之前需要进行序列化",{"2":{"154":1}}],["将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程",{"2":{"153":1}}],["将数据结构或对象转换成二进制字节流的过程",{"2":{"153":1}}],["将目标对象注入进代理类",{"2":{"147":1}}],["将字符串转成大写字符",{"2":{"137":1}}],["将字符串转成小写字母",{"2":{"137":1}}],["将会引起各种安全隐患",{"2":{"133":1}}],["将会把这些对象列进回收范围之中进行第二次回收",{"2":{"115":1}}],["将与对象相关的信息映射成一个哈希值",{"2":{"124":1}}],["将包装类型转换为基本数据类型",{"2":{"119":1}}],["将基本类型用它们对应的引用类型包装起来",{"2":{"119":1}}],["将引用分为强引用",{"2":{"115":1}}],["将代码编译成",{"2":{"109":1}}],["将其重新分配到新",{"2":{"57":1}}],["将访问指定页面的每个用户",{"2":{"27":1}}],["将每个数值在bitmap中对应的位置标记为1",{"2":{"20":1}}],["将",{"2":{"9":3,"87":1}}],["将某一时刻的内存数据",{"2":{"8":1}}],["系统调用",{"2":{"9":2}}],["www",{"2":{"181":1}}],["web",{"2":{"181":3}}],["weak",{"2":{"115":1}}],["warning",{"2":{"175":6}}],["wiki",{"2":{"181":1}}],["with",{"2":{"174":1}}],["window一句一句的将代码解释",{"2":{"111":1}}],["window会通过解释器open",{"2":{"111":1}}],["window将源代码一次性翻译成可被该平台执行的机器码",{"2":{"111":1}}],["window",{"2":{"111":1}}],["while",{"2":{"108":2,"180":1}}],["where",{"2":{"87":1}}],["writer",{"2":{"159":1}}],["write",{"2":{"9":2,"10":1,"109":1}}],["works",{"2":{"2":1}}],["会缓存到字符串常量池中",{"2":{"133":1}}],["会假设对象没有重复出现",{"2":{"127":1}}],["会判断有没有实现cloneable接口",{"2":{"124":1}}],["会在原来的对象和它的副本之间共享",{"2":{"104":1}}],["会拼接对应参数",{"2":{"91":1}}],["会跳过这个值",{"2":{"90":1}}],["会提示错误位置",{"2":{"84":1}}],["会先从外部知识库中检索相关信息",{"2":{"169":1}}],["会先计算对象的",{"2":{"127":1}}],["会先查询缓存",{"2":{"84":1,"86":1}}],["会先检查是否需要扩容",{"2":{"37":1}}],["会转换为红⿊树",{"2":{"63":1}}],["会使⽤链表来解决",{"2":{"63":1}}],["会创建",{"2":{"136":1}}],["会创建几个对象",{"0":{"136":1}}],["会创建⼀个新的数组",{"2":{"57":1}}],["会创建一个子进程来生成",{"2":{"10":1}}],["会⾃动去重",{"2":{"44":1}}],["会一直阻塞",{"2":{"28":1}}],["会发生编码转换",{"2":{"18":1}}],["会复制父进程的页表",{"2":{"10":1}}],["会通过编译器open",{"2":{"111":1}}],["会通过旧键的哈希值与旧的数组⼤⼩取模",{"2":{"57":1}}],["会通过",{"2":{"10":1,"63":1}}],["会阻塞主线程",{"2":{"10":1}}],["会调用一个信号处理函数",{"2":{"9":1}}],["会向主进程发送一条信号",{"2":{"9":1}}],["会触发什么机制",{"2":{"9":1}}],["会将命令追加到",{"2":{"9":2}}],["会读取该文件记录的命令",{"2":{"9":1}}],["执行速度比较慢",{"2":{"111":1}}],["执行速度",{"2":{"107":1}}],["执行下一步",{"2":{"86":1}}],["执行器收到通知后记录binlog",{"2":{"87":1}}],["执行器",{"2":{"84":1}}],["执行器等",{"2":{"84":1}}],["执行查询语句的时候",{"2":{"84":1}}],["执行",{"2":{"10":1,"58":1}}],["执行了",{"2":{"10":2}}],["执行完一个写命令之后",{"2":{"9":1}}],["执行完写操作命令后",{"2":{"9":2}}],["执行写操作命令和记录日志是两个过程",{"2":{"9":1}}],["把日志文件写入磁盘的时候",{"2":{"9":1}}],["但需知基础",{"2":{"181":1}}],["但需要更多的工作来适应不同的系统和编译器",{"2":{"107":1}}],["但",{"2":{"167":1}}],["但没有一个标志让",{"2":{"167":1}}],["但编译器不会报错",{"2":{"144":1}}],["但它们的功能和应用场景不同",{"2":{"164":1}}],["但它们在多个方面存在显著差异",{"2":{"107":1}}],["但它的可见范围是protected的",{"2":{"124":1}}],["但这也意味着c++程序更接近硬件层面",{"2":{"107":1}}],["但也可能导致不可预测的gc暂停时间",{"2":{"107":1}}],["但也增加了出错的风险",{"2":{"107":1}}],["但不会复制主对象里面的对象",{"2":{"104":1}}],["但不能用",{"2":{"97":1}}],["但只能继承一个抽象类",{"2":{"102":1}}],["但在整个系统中可能会出现不连续的情况",{"2":{"90":1}}],["但在高并发场景下可能会成为瓶颈",{"2":{"77":1}}],["但在需要修改数据时",{"2":{"16":1}}],["但会限制并发性",{"2":{"77":1}}],["但有可能会发⽣哈希",{"2":{"72":1}}],["但同样地",{"2":{"39":1}}],["但如果插⼊的是中间的位置",{"2":{"36":1}}],["但前提是这个key在redis中尚不存在",{"2":{"32":1}}],["但随着数据不断增加",{"2":{"27":1}}],["但像uv",{"2":{"27":1}}],["但通过",{"2":{"19":1}}],["但是这样会产生过多的代理类",{"2":{"147":1}}],["但是这样就导致代理类过于庞大",{"2":{"147":1}}],["但是这个时候binlog并没有记录该数据",{"2":{"87":1}}],["但是如果发现有相同",{"2":{"127":1}}],["但是如果插入中间的位置",{"2":{"36":1}}],["但是它的强度比软引用更弱一些",{"2":{"115":1}}],["但是同一段代码在编译后的字节码是一样的",{"2":{"112":1}}],["但是由jvm翻译成的机器码却不一样",{"2":{"110":1}}],["但是可以",{"2":{"97":1}}],["但是有不同的参数列表",{"2":{"96":1}}],["但是有两个问题",{"2":{"14":1}}],["但是",{"2":{"27":1}}],["但是数据恢复不快",{"2":{"11":1}}],["但是快照的频率不好把握",{"2":{"11":1}}],["但是页表指向的物理内存还是一个",{"2":{"10":1}}],["但是重写过程中",{"2":{"9":1}}],["但是当",{"2":{"8":1}}],["但因为",{"2":{"9":1}}],["在线博客系统",{"2":{"181":1}}],["在线课程",{"2":{"181":1}}],["在合适的时机推荐相关课程和服务",{"2":{"169":1}}],["在大语言模型生成回答之前",{"2":{"169":1}}],["在事务执行过程中",{"2":{"166":1}}],["在事务中插入数据时",{"2":{"90":1}}],["在数据库崩溃后通过重放日志保证已提交事务的修改不会丢失",{"2":{"164":1}}],["在数据量达到几十g的时候就相对麻烦了",{"2":{"76":1}}],["在utf",{"2":{"160":1}}],["在gbk中汉字占2个字节",{"2":{"160":1}}],["在序列化时就会抛出notserializableexception异常",{"2":{"156":1}}],["在序列化的时候其值会被忽略",{"2":{"155":1}}],["在被反序列化后",{"2":{"155":1}}],["在子类对象中增强目标类",{"2":{"150":1}}],["在子类中重写父类的方法",{"2":{"101":1}}],["在编译阶段将通知织入java字节码中",{"2":{"147":1}}],["在控制台上打印",{"2":{"141":1}}],["在创建字符串时",{"2":{"135":1}}],["在它创建完成之后",{"2":{"132":1}}],["在集合类中",{"2":{"118":1}}],["在系统将要发生内存溢出异常之前",{"2":{"115":1}}],["在程序代码之中普遍存在的",{"2":{"115":1}}],["在c++中",{"2":{"107":1}}],["在java1",{"2":{"115":1}}],["在java中是单继承的",{"2":{"100":1}}],["在jdk1",{"2":{"59":2}}],["在一些对server端发起的请求参数中植入一些sql代码",{"2":{"91":1}}],["在分布式系统中",{"2":{"90":2}}],["在进行数据库备份和恢复时",{"2":{"90":1}}],["在恢复数据时",{"2":{"89":1}}],["在内存中查询是否有结果",{"2":{"86":1}}],["在学生成绩表中",{"2":{"83":1}}],["在实际使用中",{"2":{"78":1}}],["在实际应用中",{"2":{"77":1}}],["在备份和恢复时可单独针对某个表进行操作",{"2":{"76":1}}],["在没有发⽣哈希冲突的情况下",{"2":{"63":1}}],["在没有信息的时候",{"2":{"28":1}}],["在扩容时会保持链表元素原本的顺序",{"2":{"58":1}}],["在多线程的环境下",{"2":{"58":1}}],["在使用",{"2":{"40":1}}],["在使用日志恢复数据时",{"2":{"9":1}}],["在遍历期间原集合发生的修改迭代器是不知道的",{"2":{"39":1}}],["在遍历时不是直接在集合内容上访问的",{"2":{"39":1}}],["在拷贝的集合上进行遍历",{"2":{"39":1}}],["在用迭代器遍历一个集合对象时",{"2":{"38":1}}],["在redis中",{"2":{"33":1}}],["在输入元素的数量或者体积非常非常大时",{"2":{"27":1}}],["在绝大部分情况",{"2":{"21":1}}],["在hash数据结构中",{"2":{"18":1}}],["在hashtable中",{"2":{"18":1}}],["在单链表中",{"2":{"17":1}}],["在不修改程序代码的情况下改变程序运行时绑定的代码",{"2":{"101":1}}],["在不影响性能的前提下",{"2":{"90":1}}],["在不同的场景下平衡了内存使用效率和数据操作性能",{"2":{"16":1}}],["在不满足使用压缩列表的条件下",{"2":{"16":1}}],["在ziplist中",{"2":{"16":1,"18":1}}],["在",{"2":{"11":1,"27":1,"61":1,"65":1,"72":1,"108":2,"139":1}}],["在这个过程中",{"2":{"10":1}}],["在执行前会再次检查权限",{"2":{"84":1}}],["在执行",{"2":{"10":1}}],["在执行快照的时候",{"2":{"10":1}}],["在执行完一条写操作命令后",{"2":{"9":1}}],["在重写",{"2":{"9":1}}],["在还没来得及将命令写入到硬盘时",{"2":{"9":1}}],["那为什么",{"2":{"160":1}}],["那为了保证内存中的数据不会丢失",{"2":{"8":1}}],["那就不必在进行equals的比较",{"2":{"129":1}}],["那这两个对象的",{"2":{"128":1,"129":1}}],["那会造成前一个",{"2":{"58":1}}],["那用户购物车信息的维护具体应该怎么操作呢",{"2":{"22":1}}],["那样还需要额外执行操作命令的步骤才能恢复数据",{"2":{"10":1}}],["那一个瞬间的画面和信息就记录到了一张照片",{"2":{"10":1}}],["那问题来了",{"2":{"9":1}}],["那么undo",{"2":{"163":1}}],["那么它是无法使用cglib做动态代理的",{"2":{"150":1}}],["那么它将首先在字符串常量池中创建",{"2":{"136":1}}],["那么它将一直留在内存中",{"2":{"133":1}}],["那么spring",{"2":{"150":1}}],["那么你只需要安装jre即可",{"2":{"112":1}}],["那么已经分配的自增",{"2":{"90":1}}],["那么自增",{"2":{"90":1}}],["那么机器重启后",{"2":{"87":1}}],["那么成绩这一非主键列应同时依赖于学号和课程编号",{"2":{"83":1}}],["那么这个类就不能用jdk动态代理",{"2":{"149":1}}],["那么这个密码可能会被改变",{"2":{"133":1}}],["那么这个对象就是不可变的",{"2":{"132":1}}],["那么这个数据集的基数集为",{"2":{"27":1}}],["那么这就是个问题了",{"2":{"69":1}}],["那么",{"2":{"62":1}}],["那么直接通过键的哈希值与数组⼤⼩取模锁定新的索引位置",{"2":{"57":1}}],["那么会调⽤",{"2":{"57":1}}],["那么会导致",{"2":{"53":1}}],["那么会发生写时复制",{"2":{"9":1}}],["那么此混合持久化",{"2":{"11":1}}],["那么在修改共享内存数据的时候",{"2":{"9":1}}],["那么如果不进行命令语法检查",{"2":{"9":1}}],["那当",{"2":{"9":1}}],["然后根据redo",{"2":{"166":1}}],["然后其value数组引用指向不同的对象",{"2":{"133":1}}],["然后拿到linux上运行",{"2":{"109":1}}],["然后用对象执行方法的方式解决问题",{"2":{"93":1}}],["然后用户",{"2":{"26":1}}],["然后写binlog",{"2":{"87":1}}],["然后调用引擎接口",{"2":{"87":2}}],["然后判断这个",{"2":{"86":1}}],["然后进行语法分析",{"2":{"84":1}}],["然后获取到类",{"2":{"68":1}}],["然后将这些检索到的内容作为额外上下文提供给模型",{"2":{"169":1}}],["然后将元素插⼊到指定的位置",{"2":{"63":1}}],["然后将每一个键值对用一条命令记录到",{"2":{"9":1}}],["然后遍历旧哈希表中的元素",{"2":{"57":1}}],["然后让hashcode的高16位和低16位进行异或操作",{"2":{"55":1}}],["然后在代理类的对应方法调用目标类中的对应方法",{"2":{"147":1}}],["然后在堆空间中创建",{"2":{"136":1}}],["然后在新副本上执行写操作",{"2":{"42":1}}],["然后在所有包含该节点的层级中移除它",{"2":{"17":1}}],["然后操作包装后的",{"2":{"40":1}}],["然后把原数组的值拷贝过去",{"2":{"37":1}}],["然后再检查有没有信息",{"2":{"28":1}}],["然后主线程处理的操作命令会被记录在重写缓冲区里",{"2":{"11":1}}],["然后每隔一秒将缓冲区里的内容写回到硬盘",{"2":{"9":1}}],["然后通过存储引擎接口访问数据",{"2":{"84":1}}],["然后通过哈希值计算出",{"2":{"63":1}}],["然后通过随机函数决定新节点应该出现在哪些层级的索引中",{"2":{"17":1}}],["然后通过",{"2":{"9":2}}],["然后逐一执行命令的方式来进行数据恢复",{"2":{"9":1}}],["然后",{"2":{"9":1,"10":1}}],["就能",{"2":{"169":1}}],["就像给",{"2":{"169":1}}],["就一定会写入日志",{"2":{"167":1}}],["就出现了包装类型",{"2":{"118":1}}],["就需要把插⼊位置后的元素向前或者向后移动",{"2":{"36":1}}],["就需要把插入位置后的元素都向前或者向后移动",{"2":{"36":1}}],["就可以恢复数据",{"2":{"167":1}}],["就可以运行字节码文件",{"2":{"110":1}}],["就可以做进一步的处理",{"2":{"68":1}}],["就可以使⽤",{"2":{"44":1}}],["就可以计算接近",{"2":{"27":1}}],["就可能会出错",{"2":{"9":1}}],["就是在线程运行",{"2":{"143":1}}],["就是",{"2":{"112":1}}],["就是java",{"2":{"112":1}}],["就是我们耳熟能详的",{"2":{"112":1}}],["就是一种建立在关系模型的基础上的数据库",{"2":{"82":1}}],["就是对应元素本身",{"2":{"26":1}}],["就是记录某一个瞬间东西",{"2":{"10":1}}],["就非常适合",{"2":{"21":2}}],["就在该层级插入新节点",{"2":{"17":1}}],["就不会让其加入操作成功",{"2":{"127":1}}],["就不能用在",{"2":{"11":1}}],["就不用加锁来保证数据安全",{"2":{"9":1}}],["就会重新散列到其他位置",{"2":{"127":1}}],["就会丢失这一条数据",{"2":{"87":1}}],["就会直接返回给客户端",{"2":{"84":1}}],["就会自动开辟一个新的页",{"2":{"80":1}}],["就会改变modcount的值",{"2":{"38":1}}],["就会进行扩容",{"2":{"37":1}}],["就会数组溢出",{"2":{"37":1}}],["就会影响性能",{"2":{"11":1}}],["就会执行后续的操作",{"2":{"84":1}}],["就会执行",{"2":{"10":1}}],["就会在主线程生成",{"2":{"10":1}}],["就会发生",{"2":{"9":1}}],["就会把该命令以追加的方式写入到一个文件里",{"2":{"9":1}}],["就将新的",{"2":{"9":1}}],["就把该命令以追加的方式写入该文件",{"2":{"8":1}}],["这时会调用",{"2":{"127":1}}],["这时要怎么办呢",{"2":{"9":1}}],["这应该是一种约定",{"2":{"124":1}}],["这",{"2":{"122":1}}],["这也就是解释了为什么浮点数没有办法用二进制精确表示",{"2":{"120":1}}],["这也是java的魅力所在",{"2":{"109":1}}],["这类的引用",{"2":{"115":1}}],["这4种引用强度依次逐渐减弱",{"2":{"115":1}}],["这一中间步骤会引入性能开销",{"2":{"107":1}}],["这提供了更高的控制能力",{"2":{"107":1}}],["这台机器会通过redo",{"2":{"87":1}}],["这就是为什么",{"2":{"167":1}}],["这就是java能够跨平台",{"2":{"112":1}}],["这就是数学的魅力么",{"2":{"19":1}}],["这就简化了出错处理和恢复的任务",{"2":{"109":1}}],["这就导致更可靠的程序",{"2":{"109":1}}],["这就称为方法重载",{"2":{"96":1}}],["这就形成了传递依赖",{"2":{"83":1}}],["这不符合1nf",{"2":{"83":1}}],["这可能导致代码功能失调并破坏可移植性",{"2":{"69":1}}],["这些redo",{"2":{"166":1}}],["这些场景都需要用到序列化",{"2":{"153":1}}],["这些异常发生时",{"2":{"139":1}}],["这些方法好像会改变string对象",{"2":{"133":1}}],["这些严格的要求保证编译程序能捕捉调用错误",{"2":{"109":1}}],["这些抽象方法需要由继承或实现它们的类来提供具体的实现",{"2":{"102":1}}],["这些锁模式可以与行锁结合使用",{"2":{"78":1}}],["这些都是因为你可以基于反射分析类",{"2":{"68":1}}],["这些框架中也大量使用了动态代理",{"2":{"68":1}}],["这是非常麻烦的",{"2":{"151":1}}],["这是非常不负责任的方式",{"2":{"144":1}}],["这是静态代理的一个优点",{"2":{"147":1}}],["这是一个标记接口",{"2":{"124":1}}],["这是通过在redis的数据库结构中的expires字典中记录每个键的过期时间来实现的",{"2":{"33":1}}],["这是真的厉害",{"2":{"19":1}}],["这意味着在并发环境下",{"2":{"32":1}}],["这和计算基数时",{"2":{"27":1}}],["这种类文件可以在虚拟机上执行",{"2":{"112":1}}],["这种字节码必须由",{"2":{"111":1}}],["这种锁对于高并发环境下的数据库性能是非常有益的",{"2":{"77":1}}],["这种查找",{"2":{"36":1}}],["这种求集合中不重复元素个数的问题称为基数问题",{"2":{"27":1}}],["这种实现方式主要是为了节省内存",{"2":{"16":1,"18":1}}],["这通常发生在键的长度过大",{"2":{"18":1}}],["这两种数据结构的应用如下",{"2":{"18":1}}],["这两种数据结构各有优劣",{"2":{"16":1}}],["这里异常的抛出条件是检测到",{"2":{"38":1}}],["这里的内容是",{"2":{"11":1}}],["这里提一点",{"2":{"10":1}}],["这里使用子进程而不是线程",{"2":{"9":1}}],["这样就可以在不修改原目标对象的前提下",{"2":{"146":1}}],["这样就大大减少了equals比较的次数",{"2":{"129":1}}],["这样我们就大大减少了",{"2":{"127":1}}],["这样可以保证哈希值的均匀分布",{"2":{"56":1}}],["这样可以避免主线程的阻塞",{"2":{"10":1}}],["这样",{"2":{"56":1,"128":1}}],["这样的方法将对象转换回原始类型的值",{"2":{"119":1}}],["这样的话",{"2":{"53":1,"147":1}}],["这样的结构允许快速的查找",{"2":{"18":1}}],["这样的好处在于",{"2":{"11":1}}],["这样加载的时候速度会很快",{"2":{"11":1}}],["这样做可以让子进程进行",{"2":{"9":1}}],["这样在",{"2":{"8":1}}],["这个有限大小的日志文件里删除",{"2":{"167":1}}],["这个过程被称为",{"2":{"166":1}}],["这个过程是异步进行的",{"2":{"166":1}}],["这个过期时间是以毫秒精度的unix时间戳来表示的",{"2":{"33":1}}],["这个记录包含了修改的类型",{"2":{"166":1}}],["这个哈希码的作用是确定该对象在哈希表中的索引位置",{"2":{"126":1}}],["这个和计算机保存浮点数的机制有很大关系",{"2":{"120":1}}],["这个jar包就可以在不同的平台上运行了",{"2":{"109":1}}],["这个问题在",{"2":{"58":1}}],["这个异常只建议用于检测并发修改的bug",{"2":{"38":1}}],["这个条件",{"2":{"38":1}}],["这个接口只是用来标识是否支持随机访问",{"2":{"36":1}}],["这个缓冲区在创建",{"2":{"9":1}}],["这个数据就会有丢失的风险",{"2":{"9":1}}],["这个机制会把数据存储到磁盘",{"2":{"8":1}}],["oop",{"2":{"180":1}}],["o流",{"0":{"158":1},"1":{"159":1,"160":1}}],["obj",{"2":{"115":1}}],["object对象有个clone",{"2":{"124":1}}],["object常用方法有",{"2":{"124":1}}],["object常用方法有哪些",{"0":{"124":1}}],["objectinputstream对象的readobject",{"2":{"113":1}}],["object",{"0":{"123":1,"134":1},"1":{"124":1,"125":1,"126":1,"127":1,"128":1,"129":1},"2":{"55":1,"115":2,"118":1,"124":1,"134":1,"146":1}}],["overload",{"2":{"97":1}}],["override",{"0":{"97":1},"2":{"97":1}}],["org",{"2":{"181":2}}],["oracle",{"2":{"181":2}}],["order",{"2":{"91":1}}],["or",{"2":{"91":1,"122":1}}],["oldcap",{"2":{"57":1}}],["o",{"0":{"160":1},"2":{"36":4,"51":1,"63":2,"160":1}}],["once",{"2":{"109":1}}],["on",{"2":{"10":1}}],["outputstream",{"2":{"159":1}}],["output",{"2":{"159":1,"174":1,"175":1}}],["outofmemoryerror",{"2":{"139":1}}],["out",{"2":{"7":1,"73":2,"176":1}}],["offset",{"2":{"19":1,"26":2}}],["of",{"2":{"2":2,"7":1,"173":1,"176":1}}],["rabbitmq",{"2":{"181":1}}],["rag",{"0":{"168":1,"169":1,"170":1},"1":{"169":1,"170":1,"171":2,"172":2},"2":{"169":4,"170":1}}],["rollback",{"2":{"181":1}}],["rpc",{"2":{"154":1}}],["rpush生产消息",{"2":{"28":1}}],["rust",{"2":{"111":1}}],["runnable",{"2":{"180":1}}],["run",{"2":{"109":1}}],["runtimeexception由程序错误导致",{"2":{"140":1}}],["runtimeexception",{"0":{"140":1}}],["runtime",{"0":{"2":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1},"2":{"2":1,"7":1,"112":1}}],["right",{"2":{"88":1}}],["rdb做快照时会阻塞线程吗",{"2":{"10":1}}],["rdb",{"2":{"10":11,"11":9,"82":1}}],["rdb快照如何实现",{"0":{"10":1}}],["rdb快照",{"2":{"8":1}}],["requestmapping",{"2":{"181":1}}],["retrieval",{"2":{"169":1}}],["return",{"2":{"55":1,"142":1,"174":2}}],["reader",{"2":{"159":1}}],["real",{"2":{"146":1}}],["replaceall这些操作的方法",{"2":{"133":1}}],["replace",{"2":{"133":1,"137":1}}],["reference",{"2":{"115":4}}],["reflection",{"2":{"67":1}}],["redo",{"0":{"162":1,"166":1,"167":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1},"2":{"163":4,"164":3,"165":3,"166":5,"167":12}}],["redolog",{"2":{"89":2}}],["redis通过其单线程模型确保了命令的原子性执行",{"2":{"33":1}}],["redis通过单线程模型执行命令",{"2":{"32":1}}],["redis会创建一个新的redisobject来存储key",{"2":{"33":1}}],["redis会采用跳表作为zset的底层数据结构",{"2":{"16":1}}],["redis是一个高性能的键值存储系统",{"2":{"33":1}}],["redis常用命令",{"0":{"30":1},"1":{"31":1,"32":1,"33":1,"34":1}}],["redis怎么实现消息队列",{"0":{"28":1}}],["redis推出了hyperloglog",{"2":{"27":1}}],["redis中最简单的数据类型",{"2":{"15":1}}],["redis存储的是key",{"2":{"15":1}}],["redis的通用命令是不分数据类型的",{"2":{"34":1}}],["redis的setex命令用于将值设置为给定的key",{"2":{"33":1}}],["redis的hash数据结构根据数据的规模和访问模式灵活地在ziplist和hashtable之间切换",{"2":{"18":1}}],["redis的hash数据结构底层原理主要基于两种数据结构",{"2":{"18":1}}],["redis的zset通过灵活地使用压缩列表和跳跃表作为底层数据结构",{"2":{"16":1}}],["redis的有序集合",{"2":{"16":1}}],["redis的数据结构",{"0":{"14":1},"1":{"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1}}],["redis的持久化",{"0":{"8":1},"1":{"9":1,"10":1,"11":1}}],["redis基础",{"0":{"12":1},"1":{"13":1,"14":1,"15":1,"16":1,"17":1,"18":1,"19":1,"20":1,"21":1,"22":1,"23":1,"24":1,"25":1,"26":1,"27":1,"28":1,"29":1,"30":1,"31":1,"32":1,"33":1,"34":1}}],["redis有三种持久化方式",{"2":{"8":1}}],["redis",{"0":{"23":1,"29":1},"2":{"8":5,"9":12,"10":8,"11":6,"13":3,"19":4,"23":2,"24":1,"27":2,"31":1,"154":1,"181":8}}],["relational",{"2":{"82":1}}],["record进行清理",{"2":{"166":1}}],["record就会被标记为",{"2":{"166":1}}],["record被写入到redo",{"2":{"166":1}}],["record重新执行这些事务的修改操作",{"2":{"166":1}}],["record来恢复未完成的事务",{"2":{"166":1}}],["record还没有被写入到磁盘上的redo",{"2":{"166":1}}],["record写入到redo",{"2":{"166":1}}],["records",{"2":{"79":1}}],["record",{"2":{"78":1,"166":1}}],["rehash",{"2":{"58":1}}],["results",{"0":{"3":1},"1":{"4":1,"5":1,"6":1},"2":{"2":1}}],["==比较的是它们的存放地址",{"2":{"125":1}}],["==比较的是他们的值",{"2":{"125":1}}],["==",{"2":{"52":1,"55":1,"57":1}}],["=64",{"2":{"48":1}}],["=expectedmodcount",{"2":{"38":1}}],["=",{"0":{"136":1},"2":{"2":1,"52":2,"55":1,"87":2,"91":1,"112":2,"115":1}}],["features",{"2":{"174":1}}],["floating",{"2":{"108":1}}],["float",{"2":{"108":1,"117":2,"118":1}}],["free",{"2":{"79":1}}],["frontmatter",{"0":{"6":1},"2":{"2":3,"6":1}}],["from",{"2":{"2":1,"181":1}}],["false",{"2":{"108":1,"117":1,"122":1}}],["fail",{"0":{"39":1},"2":{"38":1}}],["fast",{"0":{"38":1},"2":{"38":1}}],["filereader",{"2":{"180":1}}],["fileinputstream",{"2":{"180":1}}],["file",{"2":{"79":2}}],["files",{"2":{"2":1}}],["first",{"2":{"73":3,"181":1}}],["fifo",{"2":{"73":1}}],["finally语句",{"2":{"109":1}}],["finally",{"0":{"142":1},"2":{"108":2,"142":4,"143":2,"180":1}}],["final",{"2":{"55":1,"108":1,"132":1,"180":1}}],["field",{"2":{"22":3}}],["full",{"2":{"7":1,"88":1,"176":1}}],["fork",{"2":{"10":1,"11":1}}],["for",{"2":{"2":1,"7":1,"108":1,"176":1,"180":1}}],["void",{"2":{"97":1,"108":1,"141":1}}],["vector是一个历史遗留类",{"2":{"40":1}}],["vector",{"0":{"41":1},"2":{"40":1,"41":2}}],["virtual",{"2":{"112":1,"139":1}}],["visitor",{"2":{"27":1}}],["vitepress",{"2":{"2":2,"173":1,"174":1}}],["value数组用final修饰",{"2":{"132":1}}],["value注解就读取到配置文件中的值呢",{"2":{"68":1}}],["value有5种常用的数据类型",{"2":{"15":1}}],["value结构的数据",{"2":{"15":1}}],["value",{"2":{"9":2,"22":3,"31":3}}],["vue",{"2":{"2":1}}],["merge",{"2":{"181":1}}],["memory",{"2":{"75":1}}],["member2",{"2":{"25":1}}],["member1",{"2":{"25":1}}],["mvc",{"2":{"181":1}}],["mvcc比单纯的加锁更高效",{"2":{"76":1}}],["mvn",{"2":{"181":1}}],["msg",{"2":{"174":2}}],["mysql主要分为",{"2":{"84":1}}],["mysql的架构",{"0":{"84":1}}],["mysql是一个关系型数据库",{"2":{"82":1}}],["mysql基础",{"0":{"81":1},"1":{"82":1,"83":1,"84":1,"85":1,"86":1,"87":1,"88":1,"89":1,"90":1,"91":1}}],["mysql还支持多种锁模式",{"2":{"78":1}}],["mysql",{"0":{"89":1},"2":{"75":1,"84":1,"90":1,"181":6}}],["mysql中常用的四种存储引擎分别是",{"2":{"75":1}}],["myisam通过这些api与server层交互",{"2":{"84":1}}],["myisam和memory存储引擎采用表级锁",{"2":{"77":1}}],["myisam不支持聚集索引",{"2":{"76":1}}],["myisam不支持",{"2":{"76":2}}],["myisam数据是以文件的形式存储",{"2":{"76":1}}],["myisam",{"0":{"76":1},"1":{"77":1,"78":1},"2":{"75":1,"76":2}}],["mybatis中",{"2":{"91":2}}],["mybatis",{"2":{"68":1,"181":6}}],["maven",{"2":{"181":5}}],["markdown",{"0":{"173":1},"1":{"174":1,"175":1,"176":1},"2":{"173":1,"176":1}}],["machineerror",{"2":{"139":1}}],["machine",{"2":{"112":1}}],["mapper",{"2":{"181":1}}],["map",{"0":{"47":1},"1":{"48":1,"49":1,"50":1,"51":1,"52":1,"53":1,"54":1,"55":1,"56":1,"57":1,"58":1,"59":1,"60":1,"61":1,"62":1,"63":1},"2":{"59":2,"70":1,"133":1}}],["main",{"2":{"2":1,"108":1}}],["modcount",{"2":{"38":2}}],["modification",{"2":{"38":1,"39":2}}],["more",{"0":{"7":1,"176":1}}],["md```js",{"2":{"174":1}}],["md",{"2":{"2":2,"175":1}}],["is",{"2":{"175":10}}],["ioc",{"2":{"181":1}}],["io",{"0":{"159":1},"2":{"113":1,"159":4,"180":1,"181":2}}],["ieee",{"2":{"108":1}}],["implements",{"2":{"108":1}}],["import",{"2":{"2":1}}],["i",{"0":{"158":1,"160":1},"1":{"159":1,"160":1},"2":{"52":2,"160":1,"181":1}}],["if",{"2":{"32":1,"180":1}}],["idea",{"2":{"180":2,"181":2}}],["ide",{"2":{"69":1,"180":1}}],["id",{"0":{"80":1,"90":1},"2":{"14":1,"22":2,"26":1,"27":1,"87":2,"90":11}}],["info",{"2":{"175":4}}],["inputstream",{"2":{"159":1}}],["input",{"2":{"159":1,"174":1,"175":1}}],["insert",{"2":{"181":2}}],["insert语句都会给表自动加锁",{"2":{"76":1}}],["instanceof",{"2":{"108":1}}],["inner",{"0":{"88":1},"2":{"88":1}}],["innodb会给符合条件的所有行加上间隙锁",{"2":{"78":1}}],["innodb支持聚集索引",{"2":{"76":1}}],["innodb支持",{"2":{"76":1}}],["innodb内部做了很多优化",{"2":{"75":1}}],["innodb是mysql默认的事务型存储引擎",{"2":{"75":1}}],["innodb存储引擎可以通过redo",{"2":{"166":1}}],["innodb存储引擎就会将这个修改作为一个",{"2":{"166":1}}],["innodb存储引擎会定期地将redo",{"2":{"166":1}}],["innodb存储引擎会将redo",{"2":{"166":1}}],["innodb存储引擎会为这个事务分配一个连续的",{"2":{"166":1}}],["innodb存储引擎会使用redo",{"2":{"163":1}}],["innodb存储引擎支持行级锁",{"2":{"77":1}}],["innodb存储引擎",{"2":{"75":1}}],["innodb",{"0":{"76":1,"79":1,"80":1},"1":{"77":1,"78":1},"2":{"75":4,"87":1,"167":2}}],["inimum+supermum",{"2":{"79":1}}],["into",{"2":{"181":1}}],["intellij",{"2":{"180":1}}],["interrupted",{"2":{"143":1}}],["interpret",{"2":{"111":1}}],["integer等类型放⼊list中",{"2":{"145":1}}],["integer",{"2":{"118":1,"122":1}}],["int",{"2":{"36":2,"55":2,"117":2,"118":1,"126":1,"155":1,"180":1}}],["incrby轻松实现",{"2":{"27":1}}],["indexof",{"2":{"137":1}}],["index",{"2":{"19":1,"36":2,"181":2}}],["in",{"2":{"2":1,"73":2,"111":4,"173":1}}],["it",{"2":{"2":1}}],["crud",{"2":{"181":1}}],["create",{"2":{"181":1}}],["crash",{"0":{"167":1},"2":{"167":2}}],["custom",{"0":{"175":1}}],["current",{"2":{"2":1}}],["cglib是通过继承的方式做的动态代理",{"2":{"150":1}}],["cglib动态代理",{"0":{"150":1}}],["cglib",{"2":{"148":1,"150":1}}],["clean",{"2":{"181":1}}],["clone",{"2":{"124":2}}],["class的类文件",{"2":{"112":1}}],["class文件",{"2":{"109":1}}],["class",{"2":{"108":1,"110":1,"111":1,"151":1}}],["c",{"2":{"108":1,"111":1}}],["chunks",{"2":{"171":1}}],["charat",{"2":{"137":1}}],["character",{"2":{"118":1,"122":1}}],["char",{"2":{"108":2,"117":2}}],["checkedexecption",{"0":{"140":1}}],["checked",{"2":{"139":1,"140":2}}],["check",{"2":{"7":1,"176":1}}],["c++",{"2":{"108":1,"111":1}}],["c++的学习曲线更陡峭",{"2":{"107":1}}],["c++拥有一些java不支持的特性",{"2":{"107":1}}],["c++代码直接编译成机器码",{"2":{"107":1}}],["c++代码则通常需要针对每个目标平台重新编译",{"2":{"107":1}}],["c++通常提供比java更快的执行速度",{"2":{"107":1}}],["c++允许程序员直接管理内存",{"2":{"107":1}}],["c++和java都是广泛使用的编程语言",{"2":{"107":1}}],["c++和java的区别",{"0":{"107":1}}],["cookie",{"2":{"181":1}}],["code",{"2":{"150":1}}],["com",{"2":{"181":2}}],["commit",{"2":{"89":1,"181":2}}],["compaction",{"2":{"166":1}}],["comparator",{"2":{"73":1}}],["comparable",{"2":{"62":1}}],["component注解就声明了一个类为",{"2":{"68":1}}],["collection",{"2":{"70":1}}],["collections",{"2":{"40":1,"59":3,"71":1}}],["controller",{"2":{"181":2}}],["containers",{"0":{"175":1}}],["concurrenthashmap",{"2":{"59":2}}],["concurrent包下的容器都是安全失败",{"2":{"39":1}}],["const",{"2":{"2":1}}],["count计算不重复个数",{"2":{"27":1}}],["count",{"2":{"25":2}}],["counting",{"2":{"19":1}}],["cow",{"2":{"10":1}}],["copyonwritearraylist容器允许并发读",{"2":{"42":1}}],["copyonwritearraylist采用了一种读写分离的并发策略",{"2":{"42":1}}],["copyonwritearraylist就是线程安全版本的arraylist",{"2":{"42":1}}],["copyonwritearraylist",{"0":{"42":1},"2":{"40":1}}],["copy",{"2":{"10":1}}],["catch块",{"2":{"142":1}}],["catch",{"0":{"142":1},"2":{"108":6,"109":1,"139":2,"142":3,"143":2,"180":1}}],["cache",{"2":{"9":2}}],["can",{"2":{"2":1}}],["druid",{"2":{"181":1}}],["dao",{"2":{"181":1}}],["dangerous",{"2":{"175":2}}],["danger",{"2":{"175":2}}],["database",{"2":{"82":1,"181":1}}],["data",{"0":{"4":1,"5":1},"2":{"2":3,"174":2}}],["dopost",{"2":{"181":1}}],["doget",{"2":{"181":1}}],["docker",{"2":{"181":1}}],["docs",{"2":{"181":2}}],["documentation",{"2":{"7":1,"176":1}}],["doublevalue",{"2":{"119":1}}],["double",{"2":{"108":1,"117":2,"118":2}}],["do",{"2":{"108":1}}],["directory",{"2":{"79":1}}],["dk1",{"2":{"48":1}}],["debug",{"2":{"181":1}}],["details",{"2":{"175":4}}],["default",{"2":{"174":2}}],["development",{"2":{"112":1}}],["deque",{"2":{"73":1}}],["delete",{"2":{"76":1}}],["del",{"2":{"34":1}}],["demonstrates",{"2":{"2":1,"173":1}}],["swagger",{"2":{"181":1}}],["switch",{"2":{"108":3,"180":1}}],["ssm",{"2":{"181":4}}],["shiro",{"2":{"181":1}}],["shiki",{"2":{"174":1}}],["short",{"2":{"117":2,"118":1,"122":1}}],["syntax",{"0":{"174":1},"2":{"174":1}}],["synchronizedmap",{"2":{"59":3}}],["synchronized",{"2":{"41":1,"59":1,"108":1,"131":1}}],["synchronizedlist",{"2":{"40":1}}],["substring",{"2":{"137":1}}],["super",{"2":{"108":1,"180":1}}],["s",{"0":{"136":1}}],["snowflake",{"2":{"90":1}}],["sql语句只认为where后面只有一个条件",{"2":{"91":1}}],["sql语句在mysql中的执行过程",{"0":{"85":1},"1":{"86":1,"87":1}}],["sql注入的原理是将sql代码伪装到输入参数中",{"2":{"91":1}}],["sql",{"2":{"84":2,"85":1,"86":3,"91":1,"181":4}}],["s锁",{"2":{"78":1}}],["space",{"2":{"79":1}}],["springboot",{"2":{"181":3}}],["springmvc",{"2":{"181":2}}],["spring的aop使用了两种动态代理",{"2":{"148":1}}],["spring",{"2":{"68":4,"149":1,"181":6}}],["split",{"2":{"57":1,"137":1}}],["spop",{"2":{"25":1}}],["started",{"2":{"181":2}}],["static",{"0":{"157":1},"2":{"55":1,"108":1,"157":1,"180":1}}],["strong",{"2":{"115":1}}],["strict",{"2":{"108":1}}],["strictfp",{"2":{"108":2}}],["string对象创建之后",{"2":{"133":1}}],["string对象其实在内部就是一个个字符",{"2":{"132":1}}],["string是不可变的",{"2":{"132":1}}],["string类内部所有的字段都是私有的",{"2":{"132":1}}],["stringbuilder",{"2":{"131":3,"180":1}}],["stringbuilder区别",{"0":{"131":1}}],["stringbuffer",{"0":{"131":1},"2":{"131":3}}],["string的内部结构实现上类似java的arraylist",{"2":{"15":1}}],["string",{"0":{"21":1,"22":1,"130":1,"131":1,"132":1,"134":1,"136":2,"137":1},"1":{"131":1,"132":1,"133":2,"134":1,"135":1,"136":1,"137":1},"2":{"13":1,"14":2,"15":1,"21":5,"131":3,"134":2,"135":2,"141":3,"180":2,"181":1}}],["stream流",{"0":{"64":1},"1":{"65":1}}],["stream",{"2":{"13":1,"14":1,"65":1}}],["sds",{"2":{"33":1}}],["srandmember",{"2":{"25":1}}],["safe",{"0":{"39":1,"167":1},"2":{"167":1}}],["sadd",{"2":{"25":1}}],["save",{"2":{"10":3}}],["skip",{"2":{"17":1}}],["skiplist",{"2":{"16":1}}],["soft",{"2":{"115":1}}],["sorted",{"2":{"15":1,"19":1,"23":1}}],["some",{"2":{"2":1,"173":1}}],["score",{"2":{"14":1,"15":1}}],["script>",{"2":{"2":1}}],["script",{"2":{"2":1}}],["security",{"2":{"181":1}}],["seconds",{"2":{"31":2}}],["sequence",{"2":{"166":1}}],["service",{"2":{"181":1}}],["servlet",{"2":{"181":1}}],["server端在执行sql操作时",{"2":{"91":1}}],["server层会对其进行身份认证和权限校验",{"2":{"84":1}}],["server",{"2":{"9":2,"84":3}}],["serializable接口也仅仅只是做一个标记用",{"2":{"156":1}}],["serializable",{"0":{"156":1}}],["select语句",{"2":{"84":1}}],["select",{"2":{"76":1,"181":2}}],["session",{"2":{"14":1,"181":1}}],["setter",{"2":{"180":1}}],["setnx命令只在给定的key不存在时设置其值",{"2":{"32":1}}],["setnx命令的原理",{"0":{"32":1}}],["setnx",{"2":{"31":1,"32":1}}],["setex命令允许用户为键设置一个过期时间",{"2":{"33":1}}],["setex命令是用于设置一个带有过期时间的键值对",{"2":{"33":1}}],["setex命令的原理",{"0":{"33":1}}],["setex",{"2":{"31":1}}],["set",{"0":{"24":1,"25":1,"43":1},"1":{"44":1,"45":1,"46":1},"2":{"13":1,"14":2,"15":2,"19":1,"22":1,"23":1,"24":2,"25":1,"27":1,"31":1,"32":1,"65":1,"70":2,"87":1}}],["setup>",{"2":{"2":1}}],["site",{"2":{"2":1}}],["autowired",{"2":{"181":1}}],["augmented",{"2":{"169":1}}],["ai",{"2":{"169":4}}],["aop会选择使用cglib来动态代理目标类",{"2":{"150":1}}],["aop会选择使用jdk动态代理目标类",{"2":{"149":1}}],["aof重写机制",{"2":{"9":1}}],["aof写回策略有几种",{"2":{"9":1}}],["aof",{"2":{"9":36,"10":6,"11":19}}],["aof日志过大",{"2":{"9":1}}],["aof日志如何实现",{"0":{"9":1}}],["aof日志",{"2":{"8":1}}],["abc",{"0":{"136":1},"2":{"136":1}}],["abstract",{"2":{"102":1,"108":1}}],["an",{"2":{"175":2}}],["anywhere",{"2":{"109":1}}],["and",{"2":{"2":2}}],["a",{"2":{"83":1,"175":8}}],["acid",{"2":{"82":1,"181":1}}],["access",{"2":{"2":1}}],["archive",{"2":{"75":1}}],["arraydeque",{"2":{"73":1}}],["arrays",{"2":{"71":1}}],["arraylist的扩容是创建一个1",{"2":{"37":1}}],["arraylist是基于数组的集合",{"2":{"37":1}}],["arraylist是预先定义好的数组",{"2":{"36":1}}],["arraylist扩容机制",{"0":{"37":1}}],["arraylist基于数组",{"2":{"36":2}}],["arraylist基于数组实现",{"2":{"36":2}}],["arraylist增删如果是数组末尾的位置",{"2":{"36":1}}],["arraylist更利于查找",{"2":{"36":1}}],["arraylist",{"0":{"36":1,"40":1,"41":1,"45":1},"2":{"40":5,"41":1,"45":3,"70":1,"72":2,"180":1}}],["apache",{"2":{"181":1}}],["applet",{"2":{"69":1}}],["apis",{"2":{"2":1,"7":1}}],["api",{"0":{"2":1},"1":{"3":1,"4":1,"5":1,"6":1,"7":1},"2":{"2":1,"19":1,"69":1,"180":1}}],["after",{"2":{"61":1}}],["amp",{"2":{"48":1,"52":1,"56":4,"57":2}}],["additional",{"2":{"174":1}}],["add",{"2":{"44":1,"46":1}}],["always",{"2":{"9":1}}],["tutorial",{"2":{"181":2}}],["tip",{"2":{"175":4}}],["trim",{"2":{"137":1}}],["transient关键字",{"0":{"155":1}}],["transient",{"2":{"108":1,"155":1}}],["trailer",{"2":{"79":1}}],["try块",{"2":{"142":1}}],["try",{"0":{"142":1},"2":{"108":3,"142":2,"143":2,"180":1}}],["true",{"0":{"129":1},"2":{"108":1,"117":1,"122":1}}],["treeset",{"2":{"70":1}}],["treemap",{"0":{"62":1,"63":1},"2":{"60":1,"62":2,"63":2}}],["treeifybin",{"2":{"52":1}}],["table",{"2":{"181":1}}],["tab",{"2":{"52":2}}],["type",{"2":{"34":1}}],["token",{"2":{"171":1}}],["touppercase",{"2":{"137":1}}],["tolowercase",{"2":{"137":1}}],["tostring",{"2":{"124":2,"141":1}}],["to",{"2":{"2":1}}],["thread",{"2":{"180":1}}],["threshold",{"2":{"52":1,"58":1}}],["throw和throws的区别",{"0":{"144":1}}],["throwable",{"0":{"141":1},"2":{"139":2,"141":2}}],["throws抛出异常时",{"2":{"144":1}}],["throws可以一次性抛出多个异常",{"2":{"144":1}}],["throws用于方法头",{"2":{"144":1}}],["throws",{"2":{"108":1}}],["throw",{"2":{"108":1}}],["theme",{"0":{"4":1},"2":{"2":4,"4":1}}],["the",{"2":{"2":3,"7":2,"173":1,"176":2}}],["this",{"2":{"2":1,"108":1,"173":1,"175":10,"180":1}}],["branch",{"2":{"181":1}}],["break",{"2":{"108":2}}],["block",{"2":{"175":2}}],["blockingqueue",{"2":{"73":1}}],["built",{"2":{"173":1}}],["buffer中的redo",{"2":{"166":2}}],["buffer",{"2":{"166":1}}],["bufferedinputstream",{"2":{"160":1}}],["buf",{"2":{"9":4}}],["b",{"2":{"83":2,"181":3}}],["bigdecimal",{"2":{"121":2}}],["bin",{"0":{"162":1,"165":1},"1":{"163":1,"164":1,"165":1,"166":1,"167":1},"2":{"163":3,"165":3}}],["binglog",{"2":{"84":1}}],["binlog主要用于数据备份和主从同步",{"2":{"163":1}}],["binlog事务是否成功",{"2":{"89":1}}],["binlog日志没有被写入",{"2":{"87":1}}],["binlog",{"0":{"167":1},"2":{"76":1,"89":2,"167":6}}],["bit",{"2":{"19":1,"26":2,"117":1}}],["bitmap的大小需要能够覆盖这个范围",{"2":{"20":1}}],["bitmap",{"0":{"20":1,"26":1},"2":{"14":1,"19":5,"26":5}}],["bitmaps等数据结构来处理",{"2":{"27":1}}],["bitmaps",{"2":{"13":1}}],["box",{"2":{"175":2}}],["boolean",{"2":{"108":2,"117":2,"118":1,"122":1,"180":1}}],["boot",{"2":{"68":1}}],["both",{"2":{"2":1}}],["bgsave",{"2":{"10":9}}],["bgrewriteaof",{"2":{"9":2}}],["bean",{"2":{"68":1,"181":1}}],["before",{"2":{"61":1}}],["be",{"2":{"2":1}}],["byte",{"2":{"26":1,"108":2,"117":2,"118":1,"122":1,"137":1}}],["by",{"2":{"2":1,"91":1,"173":1,"174":1,"181":1}}],["pdf",{"2":{"171":1}}],["pom",{"2":{"181":2}}],["powered",{"2":{"174":1}}],["pool",{"2":{"135":1}}],["point",{"2":{"108":1}}],["phantom",{"2":{"115":1}}],["php",{"2":{"111":1}}],["python",{"2":{"111":1}}],["pull",{"2":{"181":1}}],["push",{"2":{"181":1}}],["public",{"2":{"108":2}}],["put",{"0":{"46":1,"52":1,"53":1},"2":{"46":1,"53":1,"58":4,"63":2}}],["package",{"2":{"181":1}}],["path",{"2":{"180":1}}],["pattern",{"2":{"34":2}}],["pageview页面访问量",{"2":{"27":1}}],["page",{"0":{"5":1,"6":1},"2":{"2":7,"5":1,"9":2,"79":2,"173":1}}],["pfcount",{"2":{"27":1}}],["pfadd",{"2":{"27":1}}],["provides",{"2":{"174":1}}],["provided",{"2":{"2":1,"173":1}}],["protected",{"2":{"108":1}}],["printstacktrace",{"2":{"141":1}}],["private",{"2":{"108":1,"180":1}}],["priorityqueue",{"2":{"73":1}}],["preparedstatement具有预编译功能",{"2":{"91":1}}],["preparedstatement预编译防止sql注入",{"2":{"91":1}}],["prepare",{"2":{"89":1}}],["pre>",{"2":{"2":6}}]],"serializationVersion":2}';export{t as default};
