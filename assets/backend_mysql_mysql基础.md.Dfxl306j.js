import{_ as o,c as l,o as r,ag as a}from"./chunks/framework.Bpd2YlgX.js";const h=JSON.parse('{"title":"Mysql基础","description":"","frontmatter":{},"headers":[],"relativePath":"backend/mysql/mysql基础.md","filePath":"backend/mysql/mysql基础.md"}'),i={name:"backend/mysql/mysql基础.md"};function t(n,e,p,s,d,g){return r(),l("div",null,e[0]||(e[0]=[a('<h1 id="mysql基础" tabindex="-1">Mysql基础 <a class="header-anchor" href="#mysql基础" aria-label="Permalink to &quot;Mysql基础&quot;">​</a></h1><h2 id="什么是关系型数据库" tabindex="-1">什么是关系型数据库？ <a class="header-anchor" href="#什么是关系型数据库" aria-label="Permalink to &quot;什么是关系型数据库？&quot;">​</a></h2><p>关系型数据库（RDB，Relational Database）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p>大部分关系型数据库都支持事务的四大特性(ACID)。</p><p>MySQL是一个关系型数据库，它采用表的形式来存储数据,有表结构（行和列）。行代表每一行数据，列代表该行中的每个值。列上的值是有数据类型的，比如：整数、字符串、日期等等。</p><h2 id="数据库的三大范式" tabindex="-1">数据库的三大范式 <a class="header-anchor" href="#数据库的三大范式" aria-label="Permalink to &quot;数据库的三大范式&quot;">​</a></h2><p><strong>第一范式1NF</strong>(保证原子性)</p><p>确保数据库表字段的原子性。如果一个表中的“地址”列包含了省、市和具体地址，这不符合1NF，因为“地址”可以继续拆分成更细致的部分。按1NF要求，应该将“地址”拆分为“省份”、“城市”和“具体地址”等列。</p><p><strong>第二范式2NF</strong>(消除部分依赖)</p><p>首先要满足第一范式，另外包含两部分内容，一是表必须有一个主键；二是非主键列必须完全依赖于主键，而不能只依赖于主键的一部分。例如，在学生成绩表中，如果学号和课程编号组成联合主键，那么成绩这一非主键列应同时依赖于学号和课程编号，而不是仅依赖于其中之一。</p><p><strong>第三范式3NF（消除传递依赖）</strong></p><p>首先要满足第二范式，另外非主键列必须直接依赖于主键，不能存在传递依赖。即不能存在：非主键列 A 依赖于非主键列 B，非主键列 B 依赖于主键的情况。例如，如果一个表中包含学生信息和院校信息，其中学生所在院校依赖于学号，而院校地址和电话又依赖于所在院校，这就形成了传递依赖。按照3NF的要求，需要将表拆分为学生表和院校表，使每个属性都直接依赖于主键。</p><h2 id="mysql的架构-组成" tabindex="-1">Mysql的架构/组成 <a class="header-anchor" href="#mysql的架构-组成" aria-label="Permalink to &quot;Mysql的架构/组成&quot;">​</a></h2><p>MySQL主要分为 Server 层和存储引擎层：</p><ul><li><p><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。</p></li><li><p><strong>存储引擎</strong>： 实现数据的存储和提取，不同的存储引擎如InnoDB、MyISAM通过这些API与Server层交互。存储引擎层提供数据存储和提取的具体实现，而Server层通过API调用这些功能，使得不同存储引擎能够与Server层无缝对接。</p></li></ul><p><strong>Server 层基本组件</strong></p><ul><li><p><strong>连接器：</strong> 负责与客户端建立连接，并管理连接的权限验证和维持。当客户端连接 MySQL 时，server层会对其进行身份认证和权限校验。</p></li><li><p><strong>查询缓存:</strong> 执行查询语句的时候，会先查询缓存，先校验这个 select语句 是否执行过，如果有缓存这个 sql，就会直接返回给客户端，如果没有命中，就会执行后续的操作。</p></li><li><p><strong>分析器:</strong> 没有命中缓存的话，SQL 语句就会经过分析器，主要分为两步，词法分析和语法分析。首先通过词法分析识别出各个字符串的意义，然后进行语法分析，检查语句是否符合语法结构。如有错误，会提示错误位置。</p></li><li><p><strong>优化器：</strong> 优化器对查询进行优化，选择最有效的查询路径，包括索引的选择和表的读取顺序，生成执行计划，包括选择合适的索引、表扫描顺序等。</p></li><li><p><strong>执行器：</strong> 根据优化后的执行计划调用存储引擎的API来实际执行SQL语句。在执行前会再次检查权限，确认当前用户有权执行该操作，然后通过存储引擎接口访问数据。</p></li></ul><h2 id="sql语句在mysql中的执行过程" tabindex="-1">sql语句在Mysql中的执行过程 <a class="header-anchor" href="#sql语句在mysql中的执行过程" aria-label="Permalink to &quot;sql语句在Mysql中的执行过程&quot;">​</a></h2><p>其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）</p><h3 id="_1-查询语句执行流程" tabindex="-1">1.查询语句执行流程 <a class="header-anchor" href="#_1-查询语句执行流程" aria-label="Permalink to &quot;1.查询语句执行流程&quot;">​</a></h3><p>大概有4步：</p><ul><li><p>先连接器检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接返回缓存结果，如果没有，执行下一步。</p></li><li><p>通过分析器进行词法分析，提取 SQL 语句的关键元素。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p></li><li><p>接下来就是优化器进行确定执行方案，优化器根据自己的优化算法进行选择执行效率最好的一个方案</p></li><li><p>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</p></li></ul><h3 id="_2-更新语句执行流程" tabindex="-1">2.更新语句执行流程 <a class="header-anchor" href="#_2-更新语句执行流程" aria-label="Permalink to &quot;2.更新语句执行流程&quot;">​</a></h3><p>举个例子，更新语句是这样的：</p><p>update user set name = &#39;name&#39; where id = 1;</p><p>1.先查询到 id 为1的记录，有缓存会使用缓存。</p><p>2.拿到查询结果，将 name 更新为张三，然后调用引擎接口，写入更新数据，innodb 引擎将数据保存在内存中，同时记录<code>redo log</code>，此时<code>redo log</code>进入 <code>准备</code>状态。</p><p>3.执行器收到通知后记录<code>binlog</code>，然后调用引擎接口，提交<code>redo log</code>为提交状态。</p><p>4.更新完成。</p><p><strong>为什么记录完<code>redo log</code>，不直接提交，而是先进入<code>准备</code>状态？</strong></p><p>假设先写<code>redo log</code>直接提交，然后写<code>binlog</code>，写完<code>redo log</code>后，机器挂了，<code>binlog</code>日志没有被写入，那么机器重启后，这台机器会通过<code>redo log</code>恢复数据，但是这个时候<code>binlog</code>并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</p><h2 id="inner-join-left-join和right-join的区别" tabindex="-1">inner join,left join和right join的区别 <a class="header-anchor" href="#inner-join-left-join和right-join的区别" aria-label="Permalink to &quot;inner join,left join和right join的区别&quot;">​</a></h2><p>1 Join(Inner Join) <strong>内连接</strong> 查出两表完全匹配的部分。（交集）</p><p>2 Left Join 左连接 <strong>返回左表所有的行，右表返回匹配行</strong>，<strong>不匹配的返回NULL</strong></p><p>3 Right Join 右连接 <strong>返回右表所有的行，左表返回匹配行，不匹配的返回NULL</strong></p><p>4 Full Join 全连接 <strong>只要其中一个表存在匹配，则返回行</strong></p><h2 id="mysql-是如何保证数据不丢失的" tabindex="-1">MySQL 是如何保证数据不丢失的？ <a class="header-anchor" href="#mysql-是如何保证数据不丢失的" aria-label="Permalink to &quot;MySQL 是如何保证数据不丢失的？&quot;">​</a></h2><ul><li><p>只要<strong>redolog </strong>和<strong> binlog</strong> 保证持久化磁盘就能确保MySQL异常重启后回复数据</p></li><li><p>在恢复数据时，redolog 状态为 commit 则说明 binlog 也成功，直接恢复数据；如果 redolog 是 prepare，则需要查询对应的 binlog事务是否成功，决定是回滚还是执行。</p></li></ul><h2 id="什么会导致mysql-自增主键-id-不连续" tabindex="-1">什么会导致MySQL 自增主键 ID 不连续？ <a class="header-anchor" href="#什么会导致mysql-自增主键-id-不连续" aria-label="Permalink to &quot;什么会导致MySQL 自增主键 ID 不连续？&quot;">​</a></h2><p>MySQL 自增主键 ID 不连续的原因可能有以下几点：</p><ol><li><p>插入数据失败：当插入数据时，如果某些原因导致插入失败，那么自增 ID 会跳过这个值，导致不连续。</p></li><li><p>删除数据：当删除某条记录时，自增 ID 不会回退，因此会导致不连续。</p></li><li><p>事务回滚：在事务中插入数据时，如果发生错误导致事务回滚，那么已经分配的自增 ID 也会被跳过，导致不连续。</p></li><li><p>数据库备份和恢复：在进行数据库备份和恢复时，可能会涉及到数据的重新分配，导致自增 ID 不连续。</p></li><li><p>分布式系统：在分布式系统中，多个节点可能同时分配自增 ID，虽然每个节点内部是连续的，但在整个系统中可能会出现不连续的情况。</p></li><li><p>手动设置自增 ID：如果在插入数据时手动设置了自增 ID，可能会导致不连续。</p></li></ol><p>为了避免<strong>自增 ID 不连续</strong>的问题，可以采取以下措施：</p><ol><li><p>使用 UUID 作为主键，而不是自增 ID。</p></li><li><p>在不影响性能的前提下，尽量减少事务回滚和数据删除操作。</p></li><li><p>在分布式系统中，使用全局唯一 ID 生成策略，如雪花算法（Snowflake）等。</p></li></ol><h2 id="什么是sql注入-怎么解决" tabindex="-1">什么是sql注入？怎么解决？ <a class="header-anchor" href="#什么是sql注入-怎么解决" aria-label="Permalink to &quot;什么是sql注入？怎么解决？&quot;">​</a></h2><p>SQL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对server端发起的请求参数中植入一些SQL代码，server端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。</p><p><strong>如何解决SQL注入</strong></p><ul><li><p>严格的参数校验</p></li><li><p>PreparedStatement预编译防止SQL注入</p></li><li><p>PreparedStatement具有预编译功能，以上述SQL为例使用PreparedStatement预编译后的SQL为：此时SQL语句结构已固定，无论&quot;?&quot;被替换为任何参数，SQL语句只认为where后面只有一个条件，当再传入 1001 or 1 = 1时当作一个整体，语句会报错，从而达到防止SQL注入效果。</p></li><li><p>mybatis中#{}防止SQL注入</p></li><li><p>mybatis中#{}表达式防止SQL注入与PreparedStatement类似，都是对SQL语句进行预编译处理注意：#{} ：参数占位符，可防sql注入</p></li><li><p>${} ：拼接替换符，<strong>不能防止SQL注入</strong>，一般用于传入数据库对象（如：数据库名称、表名）order by 后的条件</p></li></ul>',48)]))}const q=o(i,[["render",t]]);export{h as __pageData,q as default};
