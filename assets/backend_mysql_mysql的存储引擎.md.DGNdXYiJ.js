import{_ as o,c as l,o as r,ag as i}from"./chunks/framework.BHpayLOB.js";const c=JSON.parse('{"title":"存储引擎","description":"","frontmatter":{},"headers":[],"relativePath":"backend/mysql/mysql的存储引擎.md","filePath":"backend/mysql/mysql的存储引擎.md"}'),t={name:"backend/mysql/mysql的存储引擎.md"};function a(s,n,e,p,g,d){return r(),l("div",null,n[0]||(n[0]=[i('<h1 id="存储引擎" tabindex="-1">存储引擎 <a class="header-anchor" href="#存储引擎" aria-label="Permalink to &quot;存储引擎&quot;">​</a></h1><h2 id="常见存储引擎" tabindex="-1">常见存储引擎 <a class="header-anchor" href="#常见存储引擎" aria-label="Permalink to &quot;常见存储引擎&quot;">​</a></h2><p>MySQL中常用的四种存储引擎分别是： <strong>MyISAM</strong>、<strong>InnoDB</strong>、<strong>MEMORY</strong>、<strong>ARCHIVE</strong>。</p><p>MySQL 当前默认的存储引擎是 <strong>InnoDB</strong>。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有<strong> InnoDB 支持事务</strong>。</p><p><strong>InnoDB存储引擎</strong></p><p>InnoDB是MySQL<strong>默认的事务型存储引擎</strong>，使用最广泛，基于聚簇索引建立的。InnoDB内部做了很多优化，如能够自动在内存中创建自适应hash索引，以加速读操作。</p><p><strong>优点</strong>：支持事务和崩溃修复能力；引入了行级锁和外键约束。</p><p><strong>缺点</strong>：占用的数据空间相对较大。</p><p><strong>适用场景</strong>：需要事务支持，并且有较高的并发读写频率。</p><h2 id="myisam-和-innodb-有什么区别" tabindex="-1">MyISAM 和 InnoDB 有什么区别？ <a class="header-anchor" href="#myisam-和-innodb-有什么区别" aria-label="Permalink to &quot;MyISAM 和 InnoDB 有什么区别？&quot;">​</a></h2><ol><li><p><strong>可移植性、备份及恢复</strong>。MyISAM数据是以文件的形式存储，所以在跨平台的数据转移中会很方便。在备份和恢复时可单独针对某个表进行操作。对于InnoDB，可行的方案是拷贝数据文件、备份 binlog，或者用mysqldump，在数据量达到几十G的时候就相对麻烦了。</p></li><li><p><strong>是否支持行级锁</strong>。MyISAM 只支持表级锁，用户在操作myisam表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。而InnoDB 支持行级锁和表级锁，默认为行级锁。行锁大幅度提高了多用户并发操作的性能。</p></li><li><p><strong>是否支持事务</strong>。 MyISAM 不提供事务支持。而InnoDB 提供事务支持，具有事务、回滚和崩溃修复能力。</p></li><li><p><strong>是否支持外键</strong>。MyISAM不支持，而InnoDB支持。</p></li><li><p><strong>是否支持MVCC</strong>。MyISAM不支持，InnoDB支持。应对高并发事务，MVCC比单纯的加锁更高效。</p></li><li><p><strong>是否支持聚集索引</strong>。MyISAM不支持聚集索引，InnoDB支持聚集索引。</p></li></ol><h3 id="行级锁和表级锁" tabindex="-1">行级锁和表级锁 <a class="header-anchor" href="#行级锁和表级锁" aria-label="Permalink to &quot;行级锁和表级锁&quot;">​</a></h3><p>行级锁和表级锁是数据库中用于控制并发操作的两种不同类型的锁。以下是具体分析：</p><ul><li><p><strong>行级锁</strong>：行级锁是细粒度的锁，<strong>它允许多个事务同时对同一表的不同行进行操作，只要它们不冲突</strong>。这种锁对于高并发环境下的数据库性能是非常有益的，因为它允许更高的并行度。InnoDB存储引擎支持行级锁，并且在默认情况下使用行级锁。</p></li><li><p><strong>表级锁</strong>：<strong>表级锁是粗粒度的锁，它会锁定整张表，使得在锁持有期间，其他事务无法对表中的任何数据进行写入或修改。</strong>这种锁的开销较小，加锁速度快，但会限制并发性，因为一次只有一个事务可以写入或修改表。MyISAM和MEMORY存储引擎采用表级锁，而InnoDB在特定情况下也会使用表级锁。</p></li></ul><p>总结来说，行级锁提供了更好的并发性能，适用于数据量大且需要高并发访问的场景；而表级锁在操作少量数据时更为高效，但在高并发场景下可能会成为瓶颈。在实际应用中，选择合适的锁策略取决于具体的工作负载和性能需求。</p><h3 id="行锁有哪几种" tabindex="-1">行锁有哪几种？ <a class="header-anchor" href="#行锁有哪几种" aria-label="Permalink to &quot;行锁有哪几种？&quot;">​</a></h3><p><strong>行锁主要有记录锁和间隙锁两种类型</strong>。以下是对这两种行锁的详细解释：</p><ul><li><strong>记录锁（Record Locks）</strong>：</li></ul><ol><li><p>记录锁是直接锁定某行记录的锁，通常在执行更新操作时使用。</p></li><li><p>它要求被锁定的列必须是主键或唯一索引列，以确保锁定的是单一记录。</p></li><li><p>查询语句中的条件必须使用精确匹配（如等号=），而不是范围查询（如大于&gt;、小于&lt;、LIKE等），否则可能退化为其他类型的锁，例如临键锁。</p></li></ol><ul><li><strong>间隙锁（Gap Locks）</strong>：</li></ul><ol><li><p>间隙锁是锁定一个范围内的索引记录，主要用于防止其他事务插入到这个范围内。</p></li><li><p>它基于非唯一索引，当使用范围条件查询时，InnoDB会给符合条件的所有行加上间隙锁。</p></li></ol><p>此外，MySQL还支持多种锁模式，如共享锁（S锁）和排它锁（X锁），以及意向锁等，这些锁模式可以与行锁结合使用，以提供更灵活的并发控制机制。</p><p>在实际使用中，行锁的选择和配置取决于具体的应用场景和性能要求。理解不同类型行锁的特点和适用场景，可以帮助数据库管理员或开发者优化数据库的性能，特别是在高并发的环境中。</p><h2 id="innodb-数据页结构" tabindex="-1">innoDB 数据页结构 <a class="header-anchor" href="#innodb-数据页结构" aria-label="Permalink to &quot;innoDB 数据页结构&quot;">​</a></h2><p>一个数据页大致划分七个部分</p><ul><li><p>File Header：表示页的一些通用信息，占固定的38字节。</p></li><li><p>page Header：表示数据页专有信息，占固定的56字节。</p></li><li><p>inimum+Supermum：两个虚拟的伪记录，分别表示页中的最小记录和最大记录，占固定的26字节。</p></li><li><p>User Records：真正存储我们插入的数据，大小不固定。</p></li><li><p>Free Space：页中尚未使用的部分，大小不固定。</p></li><li><p>Page Directory：页中某些记录的相对位置，也就是各个槽对应的记录在页面中的地址偏移量。</p></li><li><p>File Trailer：用于检验页是否完整，占固定大小 8 字节。</p></li></ul><h2 id="innodb-为什么要用自增-id-作为主键" tabindex="-1">InnoDB 为什么要用自增 ID 作为主键？ <a class="header-anchor" href="#innodb-为什么要用自增-id-作为主键" aria-label="Permalink to &quot;InnoDB 为什么要用自增 ID 作为主键？&quot;">​</a></h2><ul><li><p>自增主键的插入模式，符合递增插入，每次都是追加操作，不涉及挪动记录，也不会触发叶子节点的分裂。</p></li><li><p>每次插入新的记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页。</p></li><li><p>而有业务逻辑的字段做主键，不容易保证有序插入，由于每次插入主键的值近似于随机</p></li><li><p>因此每次新纪录都要被插到现有索引页得中间某个位置， 频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，写数据成本较高。</p></li></ul>',28)]))}const I=o(t,[["render",a]]);export{c as __pageData,I as default};
